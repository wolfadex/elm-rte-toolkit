[{"name":"RichText.Annotation","comment":" This module contains common constants and functions used to annotate nodes.\nAnnotations can be added to elements and text to keep track of position when doing a complex\ntransform like a lift or join, as well as add flags to a node that you can use to effect behavior,\nlike if something is selectable.\n\n    newElement =\n        element |> Element.withAnnotations (Set.singleton selection)\n\n\n# Annotations\n\n@docs selection, selectable, lift\n\n\n# Helpers\n\n@docs add, addAtPath, addToBlock, addToInline, fromNode, clear, remove, removeAtPath, removeFromBlock, removeFromInline\n\n\n# Selection\n\nThese methods are for marking selection, which is useful for keeping track of a user's selection\nwhen defining your own transforms.\n\n@docs annotateSelection, selectionFromAnnotations, clearSelectionAnnotations, isSelectable\n\n\n# Lift\n\n@docs doLift\n\n","unions":[],"aliases":[],"values":[{"name":"add","comment":" Adds the given annotation to the node.\n\n    add Annotation.selectable (Block horizontal_rule)\n    --> Returns (Block horizontal_rule) with the selectable annotation added\n\n","type":"String.String -> RichText.Node.Node -> RichText.Node.Node"},{"name":"addAtPath","comment":" Adds an annotation to the node at the given path. Returns an error if no node\nexists at that path.\n\n    Annotation.addAtPath \"myAnnotation\" path root\n\n","type":"String.String -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"addToBlock","comment":" Helper which adds the given annotation to a block node.\n","type":"String.String -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"addToInline","comment":" Helper which adds the given annotation to an inline node.\n","type":"String.String -> RichText.Model.Node.Inline -> RichText.Model.Node.Inline"},{"name":"annotateSelection","comment":" Adds the selection annotation to the paths in the selection if they exist. This is useful\nwhen defining your own transforms to keep track of which nodes are selected.\n\n    markedRoot =\n        annotateSelection normalizedSelection (State.root editorState)\n\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"clear","comment":" Removes the given annotation from this node and its children.\n\n    clear Annotation.lift root\n    --> Returns `root` but with all the lift annotations removed.\n\n","type":"String.String -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"clearSelectionAnnotations","comment":" Clears the selection annotation from the editor node. The selection annotation should be\ntransient, so it's important to clear the annotation once you're finished with it.\n\n    clearSelectionAnnotations root\n    --> Returns root but with the selection annotation removed\n\n","type":"RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"doLift","comment":" Lifts nodes that are marked with the lift annotation if possible. Note that if there are multiple\nlevels of lift annotations, you may have to call this function multiple times.\n\n    markedRoot : Block\n    markedRoot =\n        addLiftMarkToBlocksInSelection normalizedSelection root\n\n    liftedRoot : Block\n    liftedRoot =\n        doLift markedRoot\n\n","type":"RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"fromNode","comment":" Helper method to extract annotations from a node.\n\n    fromNode node\n    --> Set [\"__selectable__\"]\n\n","type":"RichText.Node.Node -> Set.Set String.String"},{"name":"isSelectable","comment":" True if a node has the `selectable` annotation or is Text, false otherwise.\n\n    isSelectable (Inline textNode)\n    --> True\n\n","type":"RichText.Node.Node -> Basics.Bool"},{"name":"lift","comment":" Represents that a node should be lifted. This annotation is transient, e.g. it should be\ncleared before a transform or command is complete.\n","type":"String.String"},{"name":"remove","comment":" Removes the given annotation from the node if it exists.\n\n    remove Annotation.selectable (Block horizontal_rule)\n    --> Returns (Block horizontal_rule) with the selectable annotation removed\n\n","type":"String.String -> RichText.Node.Node -> RichText.Node.Node"},{"name":"removeAtPath","comment":" Removes the given annotation from the node at the given path. Returns an error if no node\nexists at that path.\n\n    Annotation.removeAtPath \"myAnnotation\" path root\n\n","type":"String.String -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"removeFromBlock","comment":" Helper which removes the given annotation from a block node.\n","type":"String.String -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"removeFromInline","comment":" Helper which removes the given annotation from an inline node.\n","type":"String.String -> RichText.Model.Node.Inline -> RichText.Model.Node.Inline"},{"name":"selectable","comment":" Represents that a node can be selected. This annotation is not transient.\n","type":"String.String"},{"name":"selection","comment":" Represents that a node is currently selected. This annotation is transient, e.g. it\nshould be cleared before a transform or command is complete. This annotation is also used when\nrendering to annotate a selected node for decorators.\n","type":"String.String"},{"name":"selectionFromAnnotations","comment":" Derives the selection from selection annotations.\n\n    selectionFromAnnotations root 0 0\n    --> Just { anchorNode=[0], anchorOffset=0, focusNode=[1,2], focusOffset=0 }\n\n","type":"RichText.Model.Node.Block -> Basics.Int -> Basics.Int -> Maybe.Maybe RichText.Model.Selection.Selection"}],"binops":[]},{"name":"RichText.Commands","comment":" This module contains pre defined commands and transforms, which are the building blocks for\nmodifying the editor.\n\n\n# Commands\n\n@docs defaultCommandMap, defaultInputEventCommand, defaultKeyCommand\n\n\n# Transforms\n\n\n## Remove selection\n\n@docs removeRange, removeRangeAndInsert, removeSelectedLeafElement\n\n\n## Backspace\n\n@docs backspaceBlock, backspaceInlineElement, backspaceText, backspaceWord, selectBackward\n\n\n## Deletion\n\n@docs deleteBlock, deleteInlineElement, deleteText, deleteWord, selectForward\n\n\n## Insert\n\n@docs insertBlock, insertInline, insertLineBreak, insertText, insertNewline, insertAfterBlockLeaf\n\n\n## Join\n\n@docs joinBackward, joinForward\n\n\n## Lift\n\n@docs lift, liftEmpty\n\n\n## Split\n\n@docs splitBlock, splitBlockHeaderToNewParagraph, splitTextBlock\n\n\n## Toggle\n\nToggle commands for elements and marks\n\n@docs toggleTextBlock, toggleMark\n\n\n## Selection\n\n@docs selectAll\n\n\n## Wrap\n\n@docs wrap\n\n","unions":[],"aliases":[],"values":[{"name":"backspaceBlock","comment":" Removes the previous block leaf if the selection is at the beginning of a text block, otherwise\nreturns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p1\" ])\n                        , block\n                            (Element.element horizontalRule [])\n                            Leaf\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p2\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 2, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p1\" ])\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p2\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 1, 0 ] 0)\n\n    backspaceBlock before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"backspaceInlineElement","comment":" Removes the previous inline element if the selection is an inline element or text with offset 0.\nReturns an error if it was unable to remove the element.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    , inlineElement (Element.element image []) []\n                                    , plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 2 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    , plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1 ] 0)\n\n    backspaceInlineElement before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"backspaceText","comment":" Backspace transform for a single character. This function has a few quirks in order to take\nadvantage of native backspace behavior, namely:\n\n  - selection offset = 0, try to delete the previous text node's text\n  - selection offset = 1, remove the first character (afterwards, the reduce behavior of `apply`\n    may remove the text node)\n  - any other offset, return an error to allow browser to do the default behavior\n\n```\nbefore : State\nbefore =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , markedText \"text2\" [ mark bold [] ]\n                                ]\n                        )\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 1 ] 0)\n\nafter : State\nafter =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"tex\"\n                                , markedText \"text2\" [ mark bold [] ]\n                                ]\n                        )\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 0 ] 3)\n\nbackspaceText before == Ok after\n--> True\n```\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"backspaceWord","comment":" Removes the word before the collapsed selection, otherwise returns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"this is an ex\"\n                                    , markedText \"ample okay\" [ mark bold [] ]\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1 ] 6)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"this is an \"\n                                    , markedText \"okay\" [ mark bold [] ]\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 11)\n\n    backspaceWord before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"defaultCommandMap","comment":" A starting point for creating your own command map. Contains deletion, line break, lift,\nsplit, select all, and undo/redo behavior.\n","type":"RichText.Config.Command.CommandMap"},{"name":"defaultInputEventCommand","comment":" The default input event command does remove range when a range is selected and an insertText\nevent occurs. In this case, we want to remove range and insert the text related to the input\ndata.\n","type":"RichText.Config.Command.InputEvent -> RichText.Config.Command.NamedCommandList"},{"name":"defaultKeyCommand","comment":" The default key command does remove range when a range is selected and a regular\nkey is pressed. In this case, we want to remove range and insert the character related to that key.\n","type":"RichText.Config.Command.KeyboardEvent -> RichText.Config.Command.NamedCommandList"},{"name":"deleteBlock","comment":" Removes the next block leaf if the selection is at the end of a text block, otherwise fails\nwith an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p1\" ])\n                        , block\n                            (Element.element horizontalRule [])\n                            Leaf\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p2\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p1\" ])\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"p2\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n    deleteBlock before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"deleteInlineElement","comment":" Removes the next inline element if the selection is at the end of a text leaf or inline element.\nReturns an error if it was unable to remove the element.\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"deleteText","comment":" Delete (forward) transform for a single character. This function has a few quirks in order to take\nadvantage of native delete behavior, namely:\n\n  - selection offset = end of text leaf, try to delete the next text node's text\n  - selection offset = 1 - end of text leaf, remove the last character (afterwards, the reduce behavior of `apply`\n    may remove the text node)\n  - any other offset, return an error to allow browser to do the default behavior\n\n```\nbefore : State\nbefore =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , markedText \"text2\" [ mark bold [] ]\n                                ]\n                        )\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 0 ] 4)\n\n\nafter : State\nafter =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , markedText \"ext2\" [ mark bold [] ]\n                                ]\n                        )\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 1 ] 0)\n\ndeleteText before == Ok after\n--> True\n```\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"deleteWord","comment":" Removes the word after the collapsed selection, otherwise returns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"this is an ex\"\n                                    , markedText \"ample okay\" [ mark bold [] ]\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 11)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"this is an \"\n                                    , markedText \" okay\" [ mark bold [] ]\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 11)\n\n    deleteWord before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"insertAfterBlockLeaf","comment":" Inserts the block after a block leaf.\n\n    emptyParagraph : Block\n    emptyParagraph =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <| Array.fromList [ plainText \"\" ])\n\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"test\" ])\n                        , block\n                            (Element.element horizontalRule [])\n                            Leaf\n                        ]\n                )\n            )\n            (Just <| caret [ 1 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"test\" ])\n                        , block\n                            (Element.element horizontalRule [])\n                            Leaf\n                        , emptyParagraph\n                        ]\n                )\n            )\n            (Just <| caret [ 2, 0 ] 0)\n\n    insertAfterBlockLeaf emptyParagraph before == Ok after\n    --> True\n\n","type":"RichText.Model.Node.Block -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"insertBlock","comment":" Transform that inserts the given block at the selection. This is useful for inserting things like\nhorizontal rules or other block leaf elements.\n\nIf the selection is a range selection, the contents of that selection are first removed,\nthen the insert command happens. If the inserted block is selectable, then the resulting selection will\nbe the block, otherwise it will be the next selectable block or inline.\nReturns an error if the block could not be inserted.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"test\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n\n    horizontalRuleBlock : Block\n    horizontalRuleBlock =\n        block\n            (Element.element horizontalRule [])\n            Leaf\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"te\" ])\n                        , horizontalRuleBlock\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"st\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 1 ] 0)\n\n    insertBlock horizontalRuleBlock before == Ok after\n    --> True\n\n","type":"RichText.Model.Node.Block -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"insertInline","comment":" Inserts the inline at the current selection. If the inline is selectable,\nit selects it at offset 0, otherwise the selection becomes the next selectable item if it exists.\nReturns an error if it cannot insert.\n\n    img : Inline\n    img =\n        inlineElement (Element.element image []) []\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"te\"\n                                    , img\n                                    , plainText \"xt\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1 ] 0)\n\n    insertInline before == Ok after\n    --> True\n\n","type":"RichText.Model.Node.Inline -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"insertLineBreak","comment":" Inserts a hard break at the current selection.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"te\"\n                                    , inlineElement (Element.element hardBreak []) []\n                                    , plainText \"xt\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 2 ] 0)\n\n    insertLineBreak before == Ok after\n    --> True\n\n","type":"RichText.Config.Command.Transform"},{"name":"insertNewline","comment":" Insert a newline at the selection in elements with the name whitelisted by the String list. This\nis used by the code block element, since it only allows text (no line breaks or marks).\nThis is a somewhat specialized method, but may be useful outside of its narrow context.\n","type":"List.List String.String -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"insertText","comment":" Inserts text at the state's selection, otherwise returns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"teinsertxt\" ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 8)\n\n    insertText before == Ok after\n    --> True\n\n","type":"String.String -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"joinBackward","comment":" If the selection is collapsed and at the start of a text block, tries to join the current\nblock the previous one. Otherwise, returns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 1, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    , plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 4)\n\n    joinBackward before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"joinForward","comment":" If the selection is collapsed and at the end of a text block, tries to join the current\nblock the next one. Otherwise, returns an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text2\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 4)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    , plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 4)\n\n    joinForward before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"lift","comment":" Lifts the selected block or the closest ancestor block out of its parent node.\nIf the current selection is a range selection, this function lifts all blocks that are in the range.\nReturns an error if no lift can be done.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element blockquote [])\n                            (blockChildren <|\n                                Array.fromList\n                                    [ block (Element.element paragraph [])\n                                        (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n    lift before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"liftEmpty","comment":" Same as `lift` but only succeeds if the selection is an empty text block.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element blockquote [])\n                            (blockChildren <|\n                                Array.fromList\n                                    [ block (Element.element paragraph [])\n                                        (inlineChildren <| Array.fromList [ plainText \"\" ])\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n    liftEmpty before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"removeRange","comment":" Delete the nodes in the selection, if there is one. Succeeds if the selection is a range\nselection and a successful remove operation occurred, otherwise returns the error describing why\nremoving the nodes failed.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"hello\"\n                                    , inlineElement (Element.element image []) []\n                                    , plainText \"world\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| range [ 0, 0 ] 2 [ 0, 2 ] 2)\n\n    after : State\n    after =\n       state\n           (block\n               (Element.element doc [])\n               (blockChildren <|\n                   Array.fromList\n                       [ block\n                           (Element.element paragraph [])\n                           (inlineChildren <|\n                               Array.fromList\n                                   [ plainText \"he\"\n                                   , plainText \"rld\"\n                                   ]\n                           )\n                       ]\n               )\n           )\n           (Just <| caret [ 0, 0 ] 2)\n\n    removeRange before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"removeRangeAndInsert","comment":" Removes the contents in the state's range selection and optionally\ninserts the given text if possible. Returns an error if the selection is collapsed or\nit cannot remove the selection.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"hello\"\n                                    , inlineElement (Element.element image []) []\n                                    , plainText \"world\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| range [ 0, 0 ] 2 [ 0, 2 ] 2)\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"het\"\n                                    , plainText \"rld\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 3)\n\n    removeRangeAndInsert \"t\" before == Ok after\n    --> True\n\n","type":"String.String -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"removeSelectedLeafElement","comment":" Removes a leaf element if it is the selected element, otherwise fails with an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"hello\"\n                                    , inlineElement (Element.element image []) []\n                                    , plainText \"world\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"hello\"\n                                    , plainText \"world\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 5)\n\n    removeSelectedLeafElement before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"selectAll","comment":" Updates the state's selection to span the first and last element of the document.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| singleNodeRange [ 0, 0 ] 0 4)\n\n    selectAll before == Ok after\n    --> True\n\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"selectBackward","comment":" If the selection is collapsed at the beginning of a text block, this will select the previous\nselectable node, and change the offset to the end if it's a text node. This is useful for default\nbackspace behavior in case a join backward operation could not be made.\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"selectForward","comment":" If the selection is collapsed at the end of a text block, this will select the next\nselectable node at offset 0. This is useful for default delete behavior in case a\njoin forward operation could not be made.\n","type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"splitBlock","comment":" Split the ancestor block determined by the passed in function of the selection.\nIf the selection is a range selection, also delete its content.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        , block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 1, 0 ] 0)\n\n    splitBlock findTextBlockAncestor before == Ok after\n    --> True\n\n","type":"(RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Model.Node.Block )) -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"splitBlockHeaderToNewParagraph","comment":" Does the split block logic, but also additionally changes the second part of the split\nto the given element if it's an empty text block. This is useful for splitting a\nheader to a paragraph block.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element heading [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element heading [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        , block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 1, 0 ] 0)\n\n    splitBlockHeaderToNewParagraph before == after\n    --> True\n\n","type":"List.List String.String -> RichText.Model.Element.Element -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"splitTextBlock","comment":" Same as `splitBlock` but the searches for a text block ancestor if one exists.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        , block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 1, 0 ] 0)\n\n    splitTextBlock before == Ok after\n    --> True\n\n","type":"RichText.Config.Command.Transform"},{"name":"toggleMark","comment":" Applies the toggle action for the mark. The affected marks are sorted by the given mark order.\n\n    boldMark : Mark\n    boldMark =\n        mark bold []\n\n\n    markdownMarkOrder : MarkOrder\n    markdownMarkOrder =\n        markOrderFromSpec markdown\n\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ markedText \"\" [ boldMark ], plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n    toggleMark markdownMarkOrder boldMark Add example == Ok\n\n","type":"RichText.Model.Mark.MarkOrder -> RichText.Model.Mark.Mark -> RichText.Model.Mark.ToggleAction -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"toggleTextBlock","comment":" Changes the selected block or blocks to the onElement if one or more blocks is not that\nelement. Otherwise, it changes it to the off element. If an element is not in the allowedElements,\nthen it is unaffected.\n\nThe arguments are as follows:\n\n  - `onElement` - The element to change to if there is one or more block that is not that element\n  - `offElement` - The element to change to if all blocks are the `onElement`\n  - `convertToPlainText` - if true, strips the inline content of all marks and inline elements.\n\n```\nbefore : State\nbefore =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block (Element.element paragraph [])\n                        (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 0 ] 0)\n\n\nafter : State\nafter =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element heading [])\n                        (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 0 ] 0)\n\ntoggleTextBlock (Element.element heading []) (Element.element paragraph []) False before == Ok after\n```\n\n","type":"RichText.Model.Element.Element -> RichText.Model.Element.Element -> Basics.Bool -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"wrap","comment":" Wraps the selection in the given element. The first argument is a mapping function for each\nblock element affected by the wrap. For normal transforms, using `identity` is okay, but for things\nlike lists, you may want to apply a function to wrap an additional list item block around each node.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element blockquote [])\n                            (blockChildren <|\n                                Array.fromList\n                                    [ block\n                                        (Element.element paragraph [])\n                                        (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0 ] 0)\n\n    wrap identity (Element.element blockquote []) before == Ok after\n    --> True\n\n","type":"(RichText.Model.Node.Block -> RichText.Model.Node.Block) -> RichText.Model.Element.Element -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"}],"binops":[]},{"name":"RichText.Config.Command","comment":" This module contains types relating to defining transforms, commands and command maps\n\n\n# Command\n\n@docs transform, internal, InternalAction, NamedCommand, NamedCommandList, Command\n\n\n# Command map\n\n@docs CommandMap, CommandBinding, key, inputEvent, emptyCommandMap, set, withDefaultInputEventCommand, withDefaultKeyCommand, defaultKeyCommand, defaultInputEventCommand, combine\n\n\n# Transform\n\n@docs Transform\n\n\n# Event\n\n@docs InputEvent, KeyboardEvent, namedCommandListFromInputEvent, namedCommandListFromKeyboardEvent\n\n","unions":[{"name":"Command","comment":" `Command` is either a transform or internal action that can be applied to an editor\nvia `RichText.Editor.applyCommand`\n","args":[],"cases":[["TransformCommand",["RichText.Config.Command.Transform"]],["InternalCommand",["RichText.Config.Command.InternalAction"]]]},{"name":"CommandBinding","comment":" A command binding can either be a key press or an input event. Note that each browser has\nvarying degrees of Input Level 2 support, so relying just on input events is usually not enough to support\nall browsers. On the flip side, virtual keyboards, specifically Android virtual keyboards, can fire\nsynthetic keyboard events that don't contain the key value, so for some actions on those platforms\nyou may need rely on input events.\n","args":[],"cases":[]},{"name":"CommandMap","comment":" A command map provides bindings between keydown/beforeinput events and a list of named commands.\n\n    emptyCommandMap\n        |> set\n            [ inputEvent \"insertLineBreak\", key [ shift, enter ], key [ shift, return ] ]\n            [ ( \"insertLineBreak\", transform insertLineBreak ) ]\n\nNote that on a successful command, preventDefault is called on the associated event. This means\nthat if a key command succeeds, the input command should not be triggered.\n\n","args":[],"cases":[]},{"name":"InternalAction","comment":" `InternalAction` is a fixed set of actions that require internal editor state\nto execute. For now this only includes undo and redo.\n","args":[],"cases":[["Undo",[]],["Redo",[]]]}],"aliases":[{"name":"InputEvent","comment":" The attributes parsed from an input event.\n","args":[],"type":"{ data : Maybe.Maybe String.String, isComposing : Basics.Bool, inputType : String.String }"},{"name":"KeyboardEvent","comment":" The attributes parsed from a keyboard event.\n","args":[],"type":"{ keyCode : Basics.Int, key : String.String, altKey : Basics.Bool, metaKey : Basics.Bool, ctrlKey : Basics.Bool, shiftKey : Basics.Bool, isComposing : Basics.Bool }"},{"name":"NamedCommand","comment":" Type alias for a command with a name. Giving a command a name is useful for debugging purposes\nwhen debugging a chain of commands. The command name is also stored in the history, which can help\ndefine more advanced behavior.\n\n    ( \"removeSelection\", removeSelection )\n\n","args":[],"type":"( String.String, RichText.Config.Command.Command )"},{"name":"NamedCommandList","comment":" Type alias for a list of named commands.\n\n    [ ( \"backspaceWord\", backspaceWord ), ( \"backspace\", backspace ) ]\n\n","args":[],"type":"List.List RichText.Config.Command.NamedCommand"},{"name":"Transform","comment":" A `Transform` is a function that receives a state and returns a result either with a new modified state,\nor a String explaining why the transform couldn't be done. With the exception of internal commands, all commands\nare defined by one or more transforms.\n\n    removeSelection : Transform\n    removeSelection state =\n        Ok (state |> withSelection Nothing)\n\n","args":[],"type":"RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"}],"values":[{"name":"combine","comment":" Combines two command maps, with the second `CommandMap` commands being appended to the first\n`CommandMap`.\n\n    combine listCommandBindings defaultCommandBindings\n    --> Creates a command map that prioritizes list command bindings, then default command bindings\n\n","type":"RichText.Config.Command.CommandMap -> RichText.Config.Command.CommandMap -> RichText.Config.Command.CommandMap"},{"name":"defaultInputEventCommand","comment":" `defaultInputEventCommand` is used if there are no input event bindings set for an input event type.\n","type":"RichText.Config.Command.CommandMap -> RichText.Config.Command.InputEvent -> RichText.Config.Command.NamedCommandList"},{"name":"defaultKeyCommand","comment":" `defaultKeyCommand` is used if there are no key bindings set for a keyboard event.\n","type":"RichText.Config.Command.CommandMap -> RichText.Config.Command.KeyboardEvent -> RichText.Config.Command.NamedCommandList"},{"name":"emptyCommandMap","comment":" An empty command map\n","type":"RichText.Config.Command.CommandMap"},{"name":"inputEvent","comment":" Creates an input event key given the input event type.\n","type":"String.String -> RichText.Config.Command.CommandBinding"},{"name":"internal","comment":" Creates a command from an internal action.\n\n    internal Undo\n    --> A command that will execute undo\n\n","type":"RichText.Config.Command.InternalAction -> RichText.Config.Command.Command"},{"name":"key","comment":" Creates a key binding given a list of keys.\n","type":"List.List String.String -> RichText.Config.Command.CommandBinding"},{"name":"namedCommandListFromInputEvent","comment":" Derives a named command list from an input event.\n","type":"RichText.Config.Command.InputEvent -> RichText.Config.Command.CommandMap -> RichText.Config.Command.NamedCommandList"},{"name":"namedCommandListFromKeyboardEvent","comment":" Derives a named command list from a keyboard event. The first argument is the value of `shortKey`,\na platform dependent shortcut for either Meta or Control.\n","type":"String.String -> RichText.Config.Command.KeyboardEvent -> RichText.Config.Command.CommandMap -> RichText.Config.Command.NamedCommandList"},{"name":"set","comment":" Returns a `CommandMap` with each command binding set to the given named command list.\n\n    emptyCommandMap\n        |> set\n            [ inputEvent \"insertLineBreak\", key [ shift, enter ], key [ shift, return ] ]\n            [ ( \"insertLineBreak\", transform insertLineBreak ) ]\n\n","type":"List.List RichText.Config.Command.CommandBinding -> RichText.Config.Command.NamedCommandList -> RichText.Config.Command.CommandMap -> RichText.Config.Command.CommandMap"},{"name":"transform","comment":" Creates a command from a transform.\n\n    transform removeSelection\n    --> A command from the removeSelection transform\n\n","type":"RichText.Config.Command.Transform -> RichText.Config.Command.Command"},{"name":"withDefaultInputEventCommand","comment":" Returns a commandMap with the defaultKeyCommand set to the provided value. The defaultInputEventCommand\nis used if there are no key bindings set for a keyboard event.\n\n    emptyCommandMap\n        |> withDefaultInputEventCommand func\n\n","type":"(RichText.Config.Command.InputEvent -> RichText.Config.Command.NamedCommandList) -> RichText.Config.Command.CommandMap -> RichText.Config.Command.CommandMap"},{"name":"withDefaultKeyCommand","comment":" Returns a commandMap with the defaultKeyCommand set to the provided value.\n\n    emptyCommandMap\n        |> withDefaultKeyCommand func\n\n","type":"(RichText.Config.Command.KeyboardEvent -> RichText.Config.Command.NamedCommandList) -> RichText.Config.Command.CommandMap -> RichText.Config.Command.CommandMap"}],"binops":[]},{"name":"RichText.Config.Decorations","comment":" Decorations are functions which add a list of Html.Attribute to rendered elements and marks. They're\nuseful for adding things like event listeners and conditional styles/attributes outside of those defined in the spec.\n\n\n# Decorations\n\n@docs Decorations, ElementDecoration, MarkDecoration, emptyDecorations, elementDecorations, markDecorations, topLevelAttributes, withMarkDecorations, withElementDecorations, withTopLevelAttributes\n\n\n# Helpers\n\n@docs addElementDecoration, addMarkDecoration, selectableDecoration\n\n@docs Tagger, Message\n\n","unions":[{"name":"Decorations","comment":" `Decorations` is a collection of mark and element decorators used in th editor view.\n\n\n    decorations =\n        emptyDecorations\n            |> addElementDecoration image (selectableDecoration InternalMsg)\n\n    --> a collection of decorations that contains a single element decoration for image\n\n","args":["msg"],"cases":[]}],"aliases":[{"name":"ElementDecoration","comment":" `ElementDecoration` is a type alias for an element decoration function. The arguments\nare as follows:\n\n  - the first argument is the path to this node from the editor root\n  - the second argument is the element to decorate\n  - The third argument is the relative path of the rendered html node. This is useful if you\n    want to apply attributes to only a subset of the rendered html nodes of an element.\n\n```\n-- A decoration which adds an onclick listener to a checkbox in a custom checkbox item element\ntoggleCheckboxDecoration : Path -> Element -> Path -> List (Html.Attribute Msg)\ntoggleCheckboxDecoration editorNodePath element relativeHtmlNodePath =\n    let\n        checked =\n            Maybe.withDefault False (findBoolAttribute \"checked\" (Element.attributes element))\n    in\n    if relativeHtmlNodePath == [ 0, 0 ] then\n        [ Html.Events.onClick (ToggleCheckedTodoItem editorNodePath (not checked)) ]\n\n    else\n        []\n```\n\n","args":["msg"],"type":"RichText.Model.Node.Path -> RichText.Model.Element.Element -> RichText.Model.Node.Path -> List.List (Html.Attribute msg)"},{"name":"MarkDecoration","comment":" `MarkDecoration` is a type alias for an mark decoration function. The arguments\nare as follows:\n\n  - the first argument is the path to this node from the editor root\n  - the second argument is the mark to decorate\n  - the third argument is the relative path of the rendered html node. This is useful if you\n    want to apply attributes to only a subset of the rendered html nodes of an element.\n\n```\n-- A decoration that adds a highlight class attribute to rendered link marks\nhighlight : Path -> Mark -> Path -> List (Html.Attribute Msg)\nhighlight _ _ _ =\n    [ Html.Attributes.class \"highlight\" ]\n```\n\n","args":["msg"],"type":"RichText.Model.Node.Path -> RichText.Model.Mark.Mark -> RichText.Model.Node.Path -> List.List (Html.Attribute msg)"},{"name":"Message","comment":" The internal events that an editor has to respond to.\n","args":[],"type":"RichText.Internal.Editor.Message"},{"name":"Tagger","comment":" A mapping from an editor message to your message type.\n","args":["msg"],"type":"RichText.Config.Decorations.Message -> msg"}],"values":[{"name":"addElementDecoration","comment":" Adds an element decoration for a defined node.\n\n\n    decorations =\n        emptyDecorations\n            |> addElementDecoration image (selectableDecoration InternalMsg)\n\n    --> a collection of decorations that contains a single element decoration for image\n\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> RichText.Config.Decorations.ElementDecoration msg -> RichText.Config.Decorations.Decorations msg -> RichText.Config.Decorations.Decorations msg"},{"name":"addMarkDecoration","comment":" Adds a mark decoration for a defined mark.\n\n\n    decorations =\n        emptyDecorations\n            |> addMarkDecoration link highlight\n\n    --> a collection of decorations that contains a single mark decoration for a link\n\n","type":"RichText.Config.MarkDefinition.MarkDefinition -> RichText.Config.Decorations.MarkDecoration msg -> RichText.Config.Decorations.Decorations msg -> RichText.Config.Decorations.Decorations msg"},{"name":"elementDecorations","comment":" A dictionary of element names to a list of mark decorations.\n","type":"RichText.Config.Decorations.Decorations msg -> Dict.Dict String.String (List.List (RichText.Config.Decorations.ElementDecoration msg))"},{"name":"emptyDecorations","comment":" Empty decorations\n","type":"RichText.Config.Decorations.Decorations msg"},{"name":"markDecorations","comment":" A dictionary of mark name to a list of mark decorations.\n","type":"RichText.Config.Decorations.Decorations msg -> Dict.Dict String.String (List.List (RichText.Config.Decorations.MarkDecoration msg))"},{"name":"selectableDecoration","comment":" Useful decoration for selectable elements. Adds an onclick listener that will select the element,\nas well as adds an rte-selected class if this item is selected.\n","type":"RichText.Config.Decorations.Tagger msg -> RichText.Model.Node.Path -> RichText.Model.Element.Element -> RichText.Model.Node.Path -> List.List (Html.Attribute msg)"},{"name":"topLevelAttributes","comment":" The extra attributes added to the node with `contenteditable=\"true\"` set.\n","type":"RichText.Config.Decorations.Decorations msg -> List.List (Html.Attribute msg)"},{"name":"withElementDecorations","comment":" Creates a decorations object with the given element decorations set\n","type":"Dict.Dict String.String (List.List (RichText.Config.Decorations.ElementDecoration msg)) -> RichText.Config.Decorations.Decorations msg -> RichText.Config.Decorations.Decorations msg"},{"name":"withMarkDecorations","comment":" Creates a decorations object with the given mark decorations set\n","type":"Dict.Dict String.String (List.List (RichText.Config.Decorations.MarkDecoration msg)) -> RichText.Config.Decorations.Decorations msg -> RichText.Config.Decorations.Decorations msg"},{"name":"withTopLevelAttributes","comment":" Creates a decorations object with the given top level attributes, e.g. extra attributes that are added\nto the editor node with `contenteditable=\"true\"` set.\n","type":"List.List (Html.Attribute msg) -> RichText.Config.Decorations.Decorations msg -> RichText.Config.Decorations.Decorations msg"}],"binops":[]},{"name":"RichText.Config.ElementDefinition","comment":" An element definition describes how to serialize/deserialize an element, as well as what content\nit can have.\n\n\n# Element definition\n\n@docs ElementDefinition, elementDefinition, ElementToHtml, HtmlToElement, name, group, contentType, fromHtmlNode, toHtmlNode\n\n\n# Content type\n\n@docs ContentType, blockLeaf, inlineLeaf, blockNode, textBlock\n\n\n# Struts\n\n@docs defaultElementDefinition, defaultElementToHtml, defaultHtmlToElement\n\n","unions":[],"aliases":[{"name":"ContentType","comment":" Describes what type of node can have this element, as well as what children the node can contain.\nIt can be one of four values:\n\n  - `inlineLeaf`: An inline element, like an inline image or hard break.\n  - `blockLeaf`: A block which does not allow children, like a horizontal rule.\n  - `blockNode`: A block with block children, like a blockquote, list, or table.\n  - `textBlock`: A block with inline children, like a paragraph or heading.\n\n","args":[],"type":"RichText.Internal.Definitions.ContentType"},{"name":"ElementDefinition","comment":" A `ElementDefinition` contains information on how to serialize/deserialize an editor node,\nas well as describes what type of node and what children the node can have.\n","args":[],"type":"RichText.Internal.Definitions.ElementDefinition"},{"name":"ElementToHtml","comment":" Type alias for defining an element serialization function.\n\n    paragraphToHtml : ElementToHtml\n    paragraphToHtml _ children =\n        ElementNode \"p\" [] children\n\nNote that when defining serialization functions, children should NOT be modified in any way, otherwise\nit will potentially break the selection and rendering logic. This is because we pass in a placeholder\nto partially serialize a document in some parts of the package.\n\n","args":[],"type":"RichText.Model.Element.Element -> Array.Array RichText.Model.HtmlNode.HtmlNode -> RichText.Model.HtmlNode.HtmlNode"},{"name":"HtmlToElement","comment":" Type alias for defining an element deserialization function.\n\n    htmlToParagraph : HtmlToElement\n    htmlToParagraph definition node =\n        case node of\n            ElementNode name _ children ->\n                if name == \"p\" then\n                    Just <| ( element definition [], children )\n\n                else\n                    Nothing\n\n            _ ->\n                Nothing\n\n","args":[],"type":"RichText.Config.ElementDefinition.ElementDefinition -> RichText.Model.HtmlNode.HtmlNode -> Maybe.Maybe ( RichText.Model.Element.Element, Array.Array RichText.Model.HtmlNode.HtmlNode )"}],"values":[{"name":"blockLeaf","comment":" A block leaf is a Block that does not allow child nodes, like a horizontal rule.\n","type":"RichText.Config.ElementDefinition.ContentType"},{"name":"blockNode","comment":" A block node is a Block that has other block children, like a blockquote or list. The\nargument is the group or name of the nodes that it allows as children.\n\n    blockNode [ \"list_item\" ]\n    --> A content type for a node that only accepts child nodes who are blocks and whose is name or group is list_items.\n\n","type":"List.List String.String -> RichText.Config.ElementDefinition.ContentType"},{"name":"contentType","comment":" Describes what type of node this is and what children it can have.\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> RichText.Config.ElementDefinition.ContentType"},{"name":"defaultElementDefinition","comment":" Creates an element definition which assumes the name of the editor node is the same as the name of the\nhtml node.\n\n    defaultElementDefinition \"p\" \"block\" (textBlock [])\n    --> definition which encodes to <p>...</p> and decodes from \"<p>...</p>\"\n\n","type":"String.String -> String.String -> RichText.Config.ElementDefinition.ContentType -> RichText.Config.ElementDefinition.ElementDefinition"},{"name":"defaultElementToHtml","comment":" Creates an `ElementToHtml` function that will encode a node to the tag specified. Any\nstring attributes are converted to attributes on the node\n\n    defaultElementToHtml \"p\"\n    --> returns a function which encodes to \"<p>...</p>\"\n\n","type":"String.String -> RichText.Model.Element.Element -> Array.Array RichText.Model.HtmlNode.HtmlNode -> RichText.Model.HtmlNode.HtmlNode"},{"name":"defaultHtmlToElement","comment":" Creates an `HtmlToElement` function that will decode a node from tag specified.\n\n    defaultHtmlToElement \"p\"\n    --> returns a function which decodes from \"<p>...</p>\"\n\n","type":"String.String -> RichText.Config.ElementDefinition.ElementDefinition -> RichText.Model.HtmlNode.HtmlNode -> Maybe.Maybe ( RichText.Model.Element.Element, Array.Array RichText.Model.HtmlNode.HtmlNode )"},{"name":"elementDefinition","comment":" Defines an element. The arguments are as follows:\n\n  - `name` is the unique name of this type of node, usually something like \"paragraph\" or \"heading\"\n\n  - `group` is the group this element belongs to. Commonly, this value will be 'block' or 'inline'\n    This is used when validating the document and can be useful if you're defining complicated block structures\n    like a table or list. For example, for a markdown list, there is a 'list\\_item' group, and ordered lists\n    and unordered lists only accept children that are part of the 'list\\_item' group. The root\n    node must be of group 'root'.\n\n  - `contentType` describes what type of node this is, namely a block with block children, a block leaf,\n    a block with inline children, or an inline leaf element.\n\n  - `toHtmlNode` converts an element into html. This is used when rendering the document\n    as well as path translation and DOM validation logic.\n\n  - `fromHtmlNode` converts html to an element. Currently, this is only used for paste\n    event, but could potentially be used more generally in the future to interpret content editable\n    changes.\n\n```\n-- Define a paragraph element\nparagraph =\n    elementDefinition\n        { name = \"paragraph\"\n        , group = \"block\"\n        , contentType = textBlock [ \"inline\" ]\n        , toHtmlNode = paragraphToHtml\n        , fromHtmlNode = htmlToParagraph\n        }\n```\n\n","type":"{ name : String.String, group : String.String, contentType : RichText.Config.ElementDefinition.ContentType, toHtmlNode : RichText.Config.ElementDefinition.ElementToHtml, fromHtmlNode : RichText.Config.ElementDefinition.HtmlToElement, selectable : Basics.Bool } -> RichText.Config.ElementDefinition.ElementDefinition"},{"name":"fromHtmlNode","comment":" The deserialization function for this node. This is used for things like a paste event to\nderive editor nodes from HTML content.\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> RichText.Config.ElementDefinition.HtmlToElement"},{"name":"group","comment":" The group this node belongs to\n\n    group paragraph\n    --> \"inline\"\n\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> String.String"},{"name":"inlineLeaf","comment":" An inline leaf is an InlineElement like an image or a breaking line.\n","type":"RichText.Config.ElementDefinition.ContentType"},{"name":"name","comment":" The name of the node this element definition defines.\n\n    name paragraph\n    --> \"paragraph\"\n\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> String.String"},{"name":"textBlock","comment":" A text block node is a Block that has inline children, like a header or paragraph.\n\n  - `allowedGroups` the group or name of the nodes that it allows as children. If a list is empty, then\n    all groups are allowed.\n\n  - `allowedMarks` the name of the marks that this textblock allows. If a list is empty, then\n    all marks are allowed.\n\n    textBlock {allowedGroups: [ \"inline\" ], allowedMarks: []}\n    --> A content type for a node that only accepts child nodes who are in the \"inline\" group and allows all marks\n\n","type":"{ allowedGroups : List.List String.String, allowedMarks : List.List String.String } -> RichText.Config.ElementDefinition.ContentType"},{"name":"toHtmlNode","comment":" The serialization function for this node. This should be called internally by the editor code\nto determine selection, render the editor, and validate the DOM.\n","type":"RichText.Config.ElementDefinition.ElementDefinition -> RichText.Config.ElementDefinition.ElementToHtml"}],"binops":[]},{"name":"RichText.Config.Keys","comment":" This module contains String constants related to defining keyboard commands.\n\n@docs short, alt, meta, ctrl, shift, return, enter, backspace, delete\n\n","unions":[],"aliases":[],"values":[{"name":"alt","comment":" Alt key\n","type":"String.String"},{"name":"backspace","comment":" Backspace key\n","type":"String.String"},{"name":"ctrl","comment":" Control key\n","type":"String.String"},{"name":"delete","comment":" Delete key\n","type":"String.String"},{"name":"enter","comment":" Enter key\n","type":"String.String"},{"name":"meta","comment":" Meta key\n","type":"String.String"},{"name":"return","comment":" Return key\n","type":"String.String"},{"name":"shift","comment":" Shift key\n","type":"String.String"},{"name":"short","comment":" Platform specific modifier that is initialized on InternalEditorMsg.Init. When resolving a\ncommand binding, it resolves to `\"Meta\"` on mac/iOS and `\"Control\"` on other platforms.\n","type":"String.String"}],"binops":[]},{"name":"RichText.Config.MarkDefinition","comment":" A mark definition describes how to encode and decode a mark.\n\n\n# Mark\n\n@docs MarkDefinition, markDefinition, MarkToHtml, HtmlToMark, name, toHtmlNode, fromHtmlNode\n\n\n# Struts\n\n@docs defaultMarkDefinition, defaultMarkToHtml, defaultHtmlToMark\n\n","unions":[],"aliases":[{"name":"HtmlToMark","comment":" Type alias for a mark decoding function\n\n    htmlNodeToCode : HtmlToMark\n    htmlNodeToCode definition node =\n        case node of\n            ElementNode name _ children ->\n                if name == 'code' then\n                    Just ( mark def [], children )\n\n                else\n                    Nothing\n\n            _ ->\n                Nothing\n\n","args":[],"type":"RichText.Config.MarkDefinition.MarkDefinition -> RichText.Model.HtmlNode.HtmlNode -> Maybe.Maybe ( RichText.Model.Mark.Mark, Array.Array RichText.Model.HtmlNode.HtmlNode )"},{"name":"MarkDefinition","comment":" A mark definition defines how a mark is encoded an decoded.\n","args":[],"type":"RichText.Internal.Definitions.MarkDefinition"},{"name":"MarkToHtml","comment":" Type alias for a mark encoding function\n\n    codeToHtmlNode : MarkToHtml\n    codeToHtmlNode _ children =\n        ElementNode \"code\" [] children\n\n","args":[],"type":"RichText.Model.Mark.Mark -> Array.Array RichText.Model.HtmlNode.HtmlNode -> RichText.Model.HtmlNode.HtmlNode"}],"values":[{"name":"defaultHtmlToMark","comment":" Creates an `HtmlToMark` function that will decode a mark from the tag name specified.\n\n    defaultHtmlToMark \"b\"\n    --> returns a function which decodes from \"<b>...</b>\"\n\n","type":"String.String -> RichText.Config.MarkDefinition.MarkDefinition -> RichText.Model.HtmlNode.HtmlNode -> Maybe.Maybe ( RichText.Model.Mark.Mark, Array.Array RichText.Model.HtmlNode.HtmlNode )"},{"name":"defaultMarkDefinition","comment":" Creates a mark definition which assumes the name of the mark is the same as the name of the\nhtml node.\n\n    defaultMarkDefinition \"b\"\n    --> definition which encodes to <b>...</b> and decodes from \"<b>...</b>\"\n\n","type":"String.String -> RichText.Config.MarkDefinition.MarkDefinition"},{"name":"defaultMarkToHtml","comment":" Creates an `MarkToHtml` function that will encode a mark to html with the same name as the mark.\n\n    defaultMarkToHtml \"b\"\n    --> returns a function which encodes to \"<b>...</b>\"\n\n","type":"String.String -> RichText.Model.Mark.Mark -> Array.Array RichText.Model.HtmlNode.HtmlNode -> RichText.Model.HtmlNode.HtmlNode"},{"name":"fromHtmlNode","comment":" Function which decodes a mark from Html\n","type":"RichText.Config.MarkDefinition.MarkDefinition -> RichText.Config.MarkDefinition.HtmlToMark"},{"name":"markDefinition","comment":" Defines a mark. The arguments are as follows:\n\n  - `name` - The unique name for this mark. This should be something like 'bold' or 'link'.\n\n  - `toHtmlNode` - The function that converts the mark to html. This is used in rendering,\n    DOM validation, and path translation.\n\n  - `fromHtmlNode` - The function that converts html to marks. This is used in things\n    like paste to determine the editor nodes from html.\n\n```\n    code : MarkDefinition\n    code =\n        markDefinition {name=\"code\", toHtmlNode=codeToHtmlNode, fromHtmlNode=htmlNodeToCode}\n```\n\n","type":"{ name : String.String, toHtmlNode : RichText.Config.MarkDefinition.MarkToHtml, fromHtmlNode : RichText.Config.MarkDefinition.HtmlToMark } -> RichText.Config.MarkDefinition.MarkDefinition"},{"name":"name","comment":" Name of the mark this mark definition defines.\n\n    name code\n    --> \"code\"\n\n","type":"RichText.Config.MarkDefinition.MarkDefinition -> String.String"},{"name":"toHtmlNode","comment":" Function which encodes a mark to Html\n","type":"RichText.Config.MarkDefinition.MarkDefinition -> RichText.Config.MarkDefinition.MarkToHtml"}],"binops":[]},{"name":"RichText.Config.Spec","comment":" A spec describes what nodes and marks can be in an editor.\n\n@docs Spec, emptySpec, markDefinitions, markDefinition, elementDefinitions, elementDefinition, withMarkDefinitions, withElementDefinitions\n\n@docs MarkDefinition\n\n","unions":[{"name":"Spec","comment":" A spec describes what nodes and marks can be in an editor. It's used internally to encode an\neditor to html, and to transform html to editor nodes. Note for the latter, the order of nodes and\nmarks is significant, because that is the order in which each node and mark's decoder method is\napplied.\n\n    simpleSpec : Spec\n    simpleSpec =\n        emptySpec\n            |> withElementDefinitions\n                [ codeBlock\n                , crazyBlock\n                , paragraph\n                , image\n                ]\n            |> withMarkDefinitions\n                [ bold\n                , italic\n                ]\n\n","args":[],"cases":[]}],"aliases":[{"name":"MarkDefinition","comment":" A mark definition defines how a mark is encoded an decoded.\n","args":[],"type":"RichText.Internal.Definitions.MarkDefinition"}],"values":[{"name":"elementDefinition","comment":" Returns the element definition with the given name from a spec.\n\n    elementDefinition \"paragraph\" markdown\n    --> Just (paragraph element definition)\n\n","type":"String.String -> RichText.Config.Spec.Spec -> Maybe.Maybe RichText.Config.ElementDefinition.ElementDefinition"},{"name":"elementDefinitions","comment":" list of `ElementDefinition` from a spec\n","type":"RichText.Config.Spec.Spec -> List.List RichText.Config.ElementDefinition.ElementDefinition"},{"name":"emptySpec","comment":" An empty spec\n","type":"RichText.Config.Spec.Spec"},{"name":"markDefinition","comment":" Returns the mark definition with the given name from a spec.\n\n    markDefinition \"bold\" markdown\n    --> Just (bold mark definition)\n\n","type":"String.String -> RichText.Config.Spec.Spec -> Maybe.Maybe RichText.Config.Spec.MarkDefinition"},{"name":"markDefinitions","comment":" list of `MarkDefinition` from a spec\n","type":"RichText.Config.Spec.Spec -> List.List RichText.Config.Spec.MarkDefinition"},{"name":"withElementDefinitions","comment":" a spec with the given element definitions\n","type":"List.List RichText.Config.ElementDefinition.ElementDefinition -> RichText.Config.Spec.Spec -> RichText.Config.Spec.Spec"},{"name":"withMarkDefinitions","comment":" a spec with the given mark definitions\n","type":"List.List RichText.Config.Spec.MarkDefinition -> RichText.Config.Spec.Spec -> RichText.Config.Spec.Spec"}],"binops":[]},{"name":"RichText.Definitions","comment":"\n\n\n# Markdown spec\n\n@docs markdown\n\n\n# Definitions\n\nThe definitions used in the markdown specification.\n\n\n## Elements\n\n@docs doc, blockquote, codeBlock, hardBreak, heading, horizontalRule, image, paragraph\n\n@docs listItem, orderedList, unorderedList\n\n\n## Marks\n\n@docs bold, code, italic, link\n\n","unions":[],"aliases":[],"values":[{"name":"blockquote","comment":" A blockquote element. It can have block children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"bold","comment":" A bold mark definition.\n","type":"RichText.Config.MarkDefinition.MarkDefinition"},{"name":"code","comment":" A code mark definition.\n","type":"RichText.Config.MarkDefinition.MarkDefinition"},{"name":"codeBlock","comment":" A code block element.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"doc","comment":" The root element of a document.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"hardBreak","comment":" Hard break is an inline leaf which represents a line break in a document.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"heading","comment":" A heading element. It can have inline children. It supports one integer attribute `level`,\nwhich defaults to 1 if not set.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"horizontalRule","comment":" A horizontal rule element. It is a block leaf, e.g. it can have no children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"image","comment":" An inline image. It can have three different string attributes:\n\n  - `src` is the uri of the image to show\n  - `alt` is the alt text of the image\n  - `title` is the title of the image\n\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"italic","comment":" An italic mark definition.\n","type":"RichText.Config.MarkDefinition.MarkDefinition"},{"name":"link","comment":" A link mark definition. It can have two different string attributes:\n\n  - `href` is the url to link to\n  - `title` is the title of the link\n\n","type":"RichText.Config.MarkDefinition.MarkDefinition"},{"name":"listItem","comment":" A list item element definition. It can have block children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"markdown","comment":" A spec which is compatible with the CommonMark flavor of markdown.\n","type":"RichText.Config.Spec.Spec"},{"name":"orderedList","comment":" An ordered list element definition. It can have list item children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"paragraph","comment":" A paragraph element. It can have inline children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"},{"name":"unorderedList","comment":" An unordered list element definition. It can have list item children.\n","type":"RichText.Config.ElementDefinition.ElementDefinition"}],"binops":[]},{"name":"RichText.Editor","comment":" This is the main module for an editor, and contains functions for initializing, updating, and\nrendering an editor.\n\n\n# Model\n\n@docs Editor, init, state, shortKey, history, withHistory, changeCount\n\n\n# Config\n\n@docs Config, config, commandMap, decorations, spec\n\n\n# Update\n\n@docs Message, update, apply, applyList, applyNoForceSelection\n\n\n# View\n\n@docs view, readOnlyView\n\n","unions":[{"name":"Config","comment":" This type represents your Editor configuration, e.g. the non-comparable things that define\nthe behavior of the editor. This includes the document specification, key and input event command\nbindings, decorative functions, and tagger function.\n","args":["msg"],"cases":[]}],"aliases":[{"name":"Editor","comment":" `Editor` represents the entire state of the editor, and is what you store in your model.\n","args":[],"type":"RichText.Internal.Editor.Editor"},{"name":"Message","comment":" The internal events that an editor has to respond to.\n","args":[],"type":"RichText.Internal.Editor.Message"}],"values":[{"name":"apply","comment":" Apply a named command to the editor. If the command was successful, the resulting editor\nwill be returned, otherwise a String describing the command's error is returned.\n\nNote that after the command is executed, it is validated against the spec. If it is not valid, then\nan error is returned. If the command is successful and validated, the resulting editor state is reduced\n(via `RichText.State.reduce`) and the history is updated.\n\n    wrapBlockNode : Spec -> Model -> Model\n    wrapBlockNode spec model =\n        { model\n            | editor =\n                Result.withDefault model.editor\n                    (apply\n                        ( \"wrapBlockquote\"\n                        , transform <|\n                            wrap\n                                identity\n                                (element blockquote [])\n                        )\n                        spec\n                        model.editor\n                    )\n        }\n\n","type":"RichText.Config.Command.NamedCommand -> RichText.Config.Spec.Spec -> RichText.Editor.Editor -> Result.Result String.String RichText.Editor.Editor"},{"name":"applyList","comment":" Apply a list of named commands to the editor to try in order, returning the updated editor after\nthe first command has been successful. If no command was successful, a String describing the last\ncommand's error is returned.\n\nThis method stops execution of the commands after the first success. Its intent is to\nallow you to group your commands for different contexts, like lift, join, split,\ninto one chained command. If you want multiple commands to be executed, you may want to compose\nthe respective transform functions or call apply for each command.\n\nAs with the `apply` command, each command is validated after it is applied, and if successful,\nthe editor state is reduced and the history is updated.\n\n    liftBlock : Spec -> Model -> Model\n    liftBlock spec model =\n        { model\n            | editor =\n                Result.withDefault model.editor\n                    (applyList\n                        [ ( \"liftList\"\n                          , transform <| RichText.List.lift defaultListDefinition\n                          )\n                        , ( \"lift\"\n                          , transform <| lift\n                          )\n                        ]\n                        spec\n                        model.editor\n                    )\n        }\n\n","type":"RichText.Config.Command.NamedCommandList -> RichText.Config.Spec.Spec -> RichText.Editor.Editor -> Result.Result String.String RichText.Editor.Editor"},{"name":"applyNoForceSelection","comment":" Same as `apply`, but the selection state is not forced to update if it hasn't changed. This normally\nshould not be used, but can be useful for situations like if you have an embedded input element in a\n\"contentediable=false\" wrapper that requires focus or independent selection.\n","type":"RichText.Config.Command.NamedCommand -> RichText.Config.Spec.Spec -> RichText.Editor.Editor -> Result.Result String.String RichText.Editor.Editor"},{"name":"changeCount","comment":" Change count is a counter that gets incremented any time the editor's state gets updated. You\nmay want to use this as a quick way to see if the editor has changed via a command after the\n`update` function. Note: this is a stop gap until a good story for how programmers can react to\neditor state changes has been thought out.\n","type":"RichText.Editor.Editor -> Basics.Int"},{"name":"commandMap","comment":" The commandMap from the config object.\n","type":"RichText.Editor.Config msg -> RichText.Config.Command.CommandMap"},{"name":"config","comment":" Create the config for your `view` and `update` functions.\n\n    import RichText.Commands exposing (defaultCommandMap)\n    import RichText.Config.Decorations exposing (emptyDecorations)\n    import RichText.Definitions exposing (markdown)\n\n    type MyMsg\n        = InternalMsg Message | ...\n\n    myConfig : Config\n    myConfig =\n        config\n            { decorations = emptyDecorations\n            , commandMap = defaultCommandMap\n            , spec = markdown\n            , toMsg = InternalMsg\n            }\n\n","type":"{ decorations : RichText.Config.Decorations.Decorations msg, spec : RichText.Config.Spec.Spec, commandMap : RichText.Config.Command.CommandMap, toMsg : RichText.Editor.Message -> msg } -> RichText.Editor.Config msg"},{"name":"decorations","comment":" The decorations from the config object.\n","type":"RichText.Editor.Config msg -> RichText.Config.Decorations.Decorations msg"},{"name":"history","comment":" Retrieves the current history from the editor\n","type":"RichText.Editor.Editor -> RichText.Model.History.History"},{"name":"init","comment":" Initializes an editor\n\n    docNode : Block\n    docNode =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <| Array.fromList [ plainText \"Hello world\" ])\n                    ]\n            )\n\n    init <| State.state docNode Nothing\n\n","type":"RichText.Model.State.State -> RichText.Editor.Editor"},{"name":"readOnlyView","comment":" Renders the contents of the editor with `contenteditable` set to false and the event listeners\nremoved.\n","type":"RichText.Editor.Config msg -> RichText.Editor.Editor -> Html.Html msg"},{"name":"shortKey","comment":" The editor shortKey is a platform dependent key for command map bindings. It is initialized\nto either `\"Control\"` or `\"Meta\"` depending on if the editor webcomponent detects if the platform\nis mac/iOS or something else. Note that this gets updated after the editor has been rendered, and\ndefaults to `\"Meta\"`.\n","type":"RichText.Editor.Editor -> String.String"},{"name":"spec","comment":" The spec from the config object.\n","type":"RichText.Editor.Config msg -> RichText.Config.Spec.Spec"},{"name":"state","comment":" Retrieves the current state from the editor\n","type":"RichText.Editor.Editor -> RichText.Model.State.State"},{"name":"update","comment":" The editor's internal update function. It's important that the editor process all `Message`\nevents with the update function so it doesn't go out of sync with the virtual DOM.\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            EditorMsg editorMsg ->\n                ( { model | editor = RichText.Editor.update config editorMsg model.editor }, Cmd.none )\n\n","type":"RichText.Editor.Config msg -> RichText.Editor.Message -> RichText.Editor.Editor -> RichText.Editor.Editor"},{"name":"view","comment":" Take an editor model and config and render it in the DOM.\n","type":"RichText.Editor.Config msg -> RichText.Editor.Editor -> Html.Html msg"},{"name":"withHistory","comment":" Sets the history on the editor.\n\n    editor\n        |> withHistory newHistory\n\n","type":"RichText.Model.History.History -> RichText.Editor.Editor -> RichText.Editor.Editor"}],"binops":[]},{"name":"RichText.Html","comment":" This module contains convenience functions for encoding and decoding editor nodes to and from\nhtml. Its intent is to help developers who want to import and export editor state\nas html.\n\n@docs toHtml, toHtmlNode, fromHtml, blockFromHtml\n\n","unions":[],"aliases":[],"values":[{"name":"blockFromHtml","comment":" Convenience function that parses html and returns the first editor block that was decoded,\nor an error if there was an issue decoding the html.\n\n    exampleBlock : Block\n    exampleBlock =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , inlineElement (Element.element image [ StringAttribute \"src\" \"logo.svg\" ]) []\n                                , plainText \"text2\"\n                                ]\n                        )\n                    ]\n            )\n\n    exampleHtml : String\n    exampleHtml =\n        \"<div data-rte-doc=\\\"true\\\"><p>text<img src=\\\"logo.svg\\\">text2</p></div>\"\n\n    (Ok exampleBlock) (blockFromHtml markdown exampleHtml)\n    --> True\n\n","type":"RichText.Config.Spec.Spec -> String.String -> Result.Result String.String RichText.Model.Node.Block"},{"name":"fromHtml","comment":" Decodes an html string to an array of editor fragments, or returns an error if there was an\nissue decoding the html.\n\n    exampleBlock : Block\n    exampleBlock =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , inlineElement (Element.element image [ StringAttribute \"src\" \"logo.svg\" ]) []\n                                , plainText \"text2\"\n                                ]\n                        )\n                    ]\n            )\n\n    exampleFragment : Fragment\n    exampleFragment =\n        BlockFragment <| Array.fromList [ exampleBlock ]\n\n\n    exampleHtml : String\n    exampleHtml =\n        \"<div data-rte-doc=\\\"true\\\"><p>text<img src=\\\"logo.svg\\\">text2</p></div>\"\n\n    (Ok (Array.fromList [ exampleFragment ])) == (fromHtml markdown exampleHtml)\n    --> True\n\n","type":"RichText.Config.Spec.Spec -> String.String -> Result.Result String.String (Array.Array RichText.Node.Fragment)"},{"name":"toHtml","comment":" Converts a block to an html string.\n\n    exampleBlock : Block\n    exampleBlock =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , inlineElement (Element.element image [ StringAttribute \"src\" \"logo.svg\" ]) []\n                                , plainText \"text2\"\n                                ]\n                        )\n                    ]\n            )\n\n    exampleHtml : String\n    exampleHtml =\n        \"<div data-rte-doc=\\\"true\\\"><p>text<img src=\\\"logo.svg\\\">text2</p></div>\"\n\n    (toHtml markdown exampleBlock) == exampleHtml\n    --> True\n\n","type":"RichText.Config.Spec.Spec -> RichText.Model.Node.Block -> String.String"},{"name":"toHtmlNode","comment":" Converts a block to an HtmlNode.\n\n    exampleBlock : Block\n    exampleBlock =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <|\n                            Array.fromList\n                                [ plainText \"text\"\n                                , inlineElement (Element.element image [ StringAttribute \"src\" \"logo.svg\" ]) []\n                                , plainText \"text2\"\n                                ]\n                        )\n                    ]\n            )\n\n    exampleHtmlNode : HtmlNode\n    exampleHtmlNode =\n        ElementNode \"div\" [ ( \"data-rte-doc\", \"true\" ) ] <|\n            Array.fromList\n                [ ElementNode \"p\" [] <|\n                    Array.fromList\n                        [ TextNode \"text\"\n                        , ElementNode \"img\" [ ( \"src\", \"logo.svg\" ) ] Array.empty\n                        , TextNode \"text2\"\n                        ]\n                ]\n\n    (toHtmlNode markdown exampleBlock) == exampleHtmlNode\n    --> True\n\n","type":"RichText.Config.Spec.Spec -> RichText.Model.Node.Block -> RichText.Model.HtmlNode.HtmlNode"}],"binops":[]},{"name":"RichText.List","comment":" This module contains definitions, commands, and transforms related to lists.\n\n\n# Types and definitions\n\n@docs ListDefinition, ListType, listDefinition, defaultListDefinition, ordered, unordered, item\n\n\n# Commands\n\n@docs defaultCommandMap\n\n\n## Transforms\n\n@docs joinBackward, joinForward, lift, liftEmpty, split, wrap\n\n\n# Helpers\n\n@docs findListItemAncestor, isBeginningOfListItem, isEndOfListItem, isListNode\n\n","unions":[{"name":"ListDefinition","comment":" A list definition defines which elements represents ordered, unordered, and list items.\n","args":[],"cases":[]},{"name":"ListType","comment":" Represents if a list is ordered or unordered.\n","args":[],"cases":[["Ordered",[]],["Unordered",[]]]}],"aliases":[],"values":[{"name":"defaultCommandMap","comment":" Creates a predefined command map related to lists. You can combine this command map with others\nusing `RichText.Model.Command.combine`:\n\n    listCommandMap : CommandMap\n    listCommandMap = RichText.List.defaultCommandMap defaultListDefinition\n\n    combine listCommandMap RichText.Commands.defaultCommandMap\n\n","type":"RichText.List.ListDefinition -> RichText.Config.Command.CommandMap"},{"name":"defaultListDefinition","comment":" The default list definition, which uses `RichText.Definitions` `orderedList`, `unorderedList` and `listItem`\nelement definitions.\n","type":"RichText.List.ListDefinition"},{"name":"findListItemAncestor","comment":" Finds the closest list item ancestor and path if one exists, otherwise returns `Nothing`.\n","type":"RichText.Model.Element.Element -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Model.Node.Block )"},{"name":"isBeginningOfListItem","comment":" True if the selection is collapsed at the beginning of a list item, false otherwise.\n","type":"RichText.List.ListDefinition -> RichText.Model.Selection.Selection -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"isEndOfListItem","comment":" True if the selection is collapsed at the end of a list item, false otherwise.\n","type":"RichText.List.ListDefinition -> RichText.Model.Selection.Selection -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"isListNode","comment":" Returns true if the current node is a ordered or unordered list, false otherwise.\n","type":"RichText.List.ListDefinition -> RichText.Node.Node -> Basics.Bool"},{"name":"item","comment":" Retrieves the element template for list items\n","type":"RichText.List.ListDefinition -> RichText.Model.Element.Element"},{"name":"joinBackward","comment":" Joins a list item backwards if the selection is at the beginning of a list item, otherwise\nfails with an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1, 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                , block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 1, 0 ] 0)\n\n    joinBackward defaultListDefinition before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"joinForward","comment":" Joins a list item if the selection is at the end of a list item, otherwise fails with an error.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0, 0 ] 4)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                , block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0, 0 ] 4)\n\n    joinForward defaultListDefinition before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"lift","comment":" Lifts a list item's contents out of its parent list.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0, 0 ] 4)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        , block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 4)\n\n    lift defaultListDefinition before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"liftEmpty","comment":" Same as `lift` but only will succeed if the list item is empty.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"\"\n                                    ]\n                            )\n                        , block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 0)\n\n    liftEmpty defaultListDefinition before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"},{"name":"listDefinition","comment":" Creates a list definition\n","type":"{ ordered : RichText.Model.Element.Element, unordered : RichText.Model.Element.Element, item : RichText.Model.Element.Element } -> RichText.List.ListDefinition"},{"name":"ordered","comment":" Retrieves the element template for ordered lists\n","type":"RichText.List.ListDefinition -> RichText.Model.Element.Element"},{"name":"split","comment":" Same as `RichText.Commands.splitTextBlock`, but searches for a list item ancestor instead of a text block\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0, 0, 0 ] 2)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"te\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"xt\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 1, 0, 0 ] 0)\n\n    split defaultListDefinition before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.Config.Command.Transform"},{"name":"unordered","comment":" Retrieves the element template for unordered lists\n","type":"RichText.List.ListDefinition -> RichText.Model.Element.Element"},{"name":"wrap","comment":" Wraps the selection in a list.\n\n    before : State\n    before =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text\"\n                                    ]\n                            )\n                        , block\n                            (Element.element paragraph [])\n                            (inlineChildren <|\n                                Array.fromList\n                                    [ plainText \"text2\"\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| range [ 0, 0 ] 0 [ 1, 0 ] 0)\n\n\n    after : State\n    after =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block (Element.element orderedList [])\n                            (blockChildren <|\n                                Array.fromList <|\n                                    [ block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    , block\n                                        (Element.element listItem [])\n                                        (blockChildren <|\n                                            Array.fromList\n                                                [ block\n                                                    (Element.element paragraph [])\n                                                    (inlineChildren <|\n                                                        Array.fromList\n                                                            [ plainText \"text2\"\n                                                            ]\n                                                    )\n                                                ]\n                                        )\n                                    ]\n                            )\n                        ]\n                )\n            )\n            (Just <| range [ 0, 0, 0, 0 ] 0 [ 0, 1, 0, 0 ] 0)\n\n    wrap defaultListDefinition Ordered before == Ok after\n    --> True\n\n","type":"RichText.List.ListDefinition -> RichText.List.ListType -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"}],"binops":[]},{"name":"RichText.Model.Attribute","comment":" This module contains basic methods for accessing and defining element and mark attributes.\n\n\n# Attribute type\n\n@docs Attribute\n\n\n# Helpers\n\n@docs findBoolAttribute, findFloatAttribute, findIntegerAttribute, findStringAttribute, replaceOrAddBoolAttribute, replaceOrAddFloatAttribute, replaceOrAddIntegerAttribute, replaceOrAddStringAttribute\n\n","unions":[{"name":"Attribute","comment":" An attribute is a key value pair. It's used to store information on an element or mark.\nInformation you can store are things like color, font type, or image or link locations.\n\n    StringAttribute \"href\" \"www.google.com\"\n\n","args":[],"cases":[["StringAttribute",["String.String","String.String"]],["IntegerAttribute",["String.String","Basics.Int"]],["BoolAttribute",["String.String","Basics.Bool"]],["FloatAttribute",["String.String","Basics.Float"]]]}],"aliases":[],"values":[{"name":"findBoolAttribute","comment":" Find the first BoolAttribute that has the name provided and return Just that value. If no\nattribute exists, return Nothing.\n\n    findBoolAttribute \"foo\" [ BoolAttribute \"foo\" True, StringAttribute \"foo2\" \"bar2\" ]\n    --> Just True\n\n","type":"String.String -> List.List RichText.Model.Attribute.Attribute -> Maybe.Maybe Basics.Bool"},{"name":"findFloatAttribute","comment":" Find the first FloatAttribute that has the name provided and return Just that value. If no\nattribute exists, return Nothing.\n\n    findFloatAttribute \"foo\" [ FloatAttribute \"foo\" 1.1, StringAttribute \"foo2\" \"bar2\" ]\n    --> Just 1.1\n\n","type":"String.String -> List.List RichText.Model.Attribute.Attribute -> Maybe.Maybe Basics.Float"},{"name":"findIntegerAttribute","comment":" Find the first IntegerAttribute that has the name provided and return Just that value. If no\nattribute exists, return Nothing.\n\n    findIntegerAttribute \"foo\" [ IntegerAttribute \"foo\" 1, StringAttribute \"foo2\" \"bar2\" ]\n    --> Just 1\n\n","type":"String.String -> List.List RichText.Model.Attribute.Attribute -> Maybe.Maybe Basics.Int"},{"name":"findStringAttribute","comment":" Find the first StringAttribute that has the name provided and return Just that value. If no\nattribute exists, return Nothing.\n\n    findStringAttribute \"foo2\" [ FloatAttribute \"foo\" 1.1, StringAttribute \"foo2\" \"bar2\" ]\n    --> Just \"bar2\"\n\n","type":"String.String -> List.List RichText.Model.Attribute.Attribute -> Maybe.Maybe String.String"},{"name":"replaceOrAddBoolAttribute","comment":" Replaces all BoolAttributes that have the name provided in the list,\nor add it to the beginning of the list if no pre existing BoolAttribute exists.\n\n    replaceOrAddBoolAttribute \"foo\" True [ BoolAttribute \"foo\" False, StringAttribute \"foo2\" \"bar2\" ]\n    --> [ BoolAttribute \"foo\" True, StringAttribute \"foo2\" \"bar2\" ]\n\n","type":"String.String -> Basics.Bool -> List.List RichText.Model.Attribute.Attribute -> List.List RichText.Model.Attribute.Attribute"},{"name":"replaceOrAddFloatAttribute","comment":" Replaces all FloatAttributes that have the name provided in the list,\nor add it to the beginning of the list if no pre existing FloatAttribute exists.\n\n    replaceOrAddFloatAttribute \"foo\" 2.2 [ FloatAttribute \"foo\" 1.1, StringAttribute \"foo2\" \"bar2\" ]\n    --> [ FloatAttribute \"foo\" 2.2, StringAttribute \"foo2\" \"bar2\" ]\n\n","type":"String.String -> Basics.Float -> List.List RichText.Model.Attribute.Attribute -> List.List RichText.Model.Attribute.Attribute"},{"name":"replaceOrAddIntegerAttribute","comment":" Replaces all IntegerAttributes that have the name provided in the list,\nor add it to the beginning of the list if no pre existing IntegerAttribute exists.\n\n    replaceOrAddIntegerAttribute \"foo\" 2 [ IntegerAttribute \"foo\" 1, StringAttribute \"foo2\" \"bar2\" ]\n    --> [ IntegerAttribute \"foo\" 2, StringAttribute \"foo2\" \"bar2\" ]\n\n","type":"String.String -> Basics.Int -> List.List RichText.Model.Attribute.Attribute -> List.List RichText.Model.Attribute.Attribute"},{"name":"replaceOrAddStringAttribute","comment":" Replaces all StringAttributes that have the name provided in the list,\nor add it to the beginning of the list if no pre existing StringAttribute exists.\n\n    replaceOrAddStringAttribute \"foo2\" \"bar3\" [ BoolAttribute \"foo\" False, StringAttribute \"foo2\" \"bar2\" ]\n    --> [ BoolAttribute \"foo\" False, StringAttribute \"foo2\" \"bar3\" ]\n\n","type":"String.String -> String.String -> List.List RichText.Model.Attribute.Attribute -> List.List RichText.Model.Attribute.Attribute"}],"binops":[]},{"name":"RichText.Model.Element","comment":" An element represents the parameters of any non-text node.\n\n@docs ElementDefinition, Element, element, annotations, attributes, name, withAnnotations, withAttributes\n\n","unions":[],"aliases":[{"name":"Element","comment":" An `Element` represents the parameters of non-text nodes. It consists of an element name,\na list of attributes, and a set of annotations.\n","args":[],"type":"RichText.Internal.Definitions.Element"},{"name":"ElementDefinition","comment":" A `ElementDefinition` contains information on how to serialize/deserialize an editor node,\nas well as describes what type of node and what children the node can have.\n","args":[],"type":"RichText.Internal.Definitions.ElementDefinition"}],"values":[{"name":"annotations","comment":" Annotations from an element\n\n    annotations (element horizontal_rule [] (Set.singleton selectable))\n    --> Set [ selectable ]\n\n","type":"RichText.Model.Element.Element -> Set.Set String.String"},{"name":"attributes","comment":" Attributes from an element\n\n    attributes (element image [StringAttribute \"src\" \"logo.svg\"])\n    --> [StringAttribute \"src\" \"logo.svg\"]\n\n","type":"RichText.Model.Element.Element -> List.List RichText.Model.Attribute.Attribute"},{"name":"element","comment":" Creates an element. The arguments are as follows:\n\n  - The first argument is the `ElementDefinition` that defines this element. Note that even though\n    elements require an element definition, it's still safe to use `(==)` because the function arguments\n    are not stored on the resulting `Element`.\n\n  - The second argument is element's list of attributes.\n\n```\n    element header [IntegerAttribute \"level\" 1]\n    --> creates a header (h1) element\n```\n\n","type":"RichText.Model.Element.ElementDefinition -> List.List RichText.Model.Attribute.Attribute -> RichText.Model.Element.Element"},{"name":"name","comment":" Name from an element\n\n    name (element image [StringAttribute \"src\" \"logo.svg\"])\n    --> \"image\"\n\n","type":"RichText.Model.Element.Element -> String.String"},{"name":"withAnnotations","comment":" An element with the annotations changed to the given set\n\n    element <| withAnnotations (Set.singleton selectable)\n    --> an element with the annotations changed to the singleton selectable set\n\n","type":"Set.Set String.String -> RichText.Model.Element.Element -> RichText.Model.Element.Element"},{"name":"withAttributes","comment":" An element with the attributes changed to the given list\n\n    element <| withAnnotations [StringAttribute \"src\" \"logo.svg\"]\n    --> an element with the attributes changed to the list provided\n\n","type":"List.List RichText.Model.Attribute.Attribute -> RichText.Model.Element.Element -> RichText.Model.Element.Element"}],"binops":[]},{"name":"RichText.Model.History","comment":" This module contains the type used to store undo/redo history.\n\n@docs History, empty, peek, undoList, redoList\n\n","unions":[],"aliases":[{"name":"History","comment":" `History` contains the undo deque and redo stack related to undo history.\n","args":[],"type":"RichText.Internal.History.History"}],"values":[{"name":"empty","comment":" Provides an empty `History` with the given config. The config values are as follows:\n\n  - `groupDelayMilliseconds` is the interval which the editor will ignore adding multiple text changes onto the undo stack. This is\n    so the history doesn't get overwhelmed by single character changes.\n  - `size` is the number of states stored in the history\n\n","type":"{ groupDelayMilliseconds : Basics.Int, size : Basics.Int } -> RichText.Model.History.History"},{"name":"peek","comment":" Returns the last executed action and previous state on the undo stack.\n","type":"RichText.Model.History.History -> Maybe.Maybe ( String.String, RichText.Model.State.State )"},{"name":"redoList","comment":" Returns the entire redo stack.\n","type":"RichText.Model.History.History -> List.List RichText.Model.State.State"},{"name":"undoList","comment":" Returns the entire undo stack.\n","type":"RichText.Model.History.History -> List.List ( String.String, RichText.Model.State.State )"}],"binops":[]},{"name":"RichText.Model.HtmlNode","comment":" `HtmlNode` is used to determine how to render the editor. We don't use the built in Html library\nbecause we can't inspect a node after it has been created.\n\n@docs HtmlNode, HtmlAttribute\n\n","unions":[{"name":"HtmlNode","comment":" An HTML node. It can be either an `ElementNode` or `TextNode`\n\n    ElementNode \"p\" [ ( \"class\", \"my-paragraph\" ) ] (Array.fromList [ Text \"sample\" ])\n\n","args":[],"cases":[["ElementNode",["String.String","List.List RichText.Model.HtmlNode.HtmlAttribute","Array.Array RichText.Model.HtmlNode.HtmlNode"]],["TextNode",["String.String"]]]}],"aliases":[{"name":"HtmlAttribute","comment":" An HTML attribute:\n\n    ( \"src\", \"logo.svg\" )\n\n","args":[],"type":"( String.String, String.String )"}],"values":[],"binops":[]},{"name":"RichText.Model.InlineElement","comment":" An inline element is an element with marks. It represents the contents of an inline node that is\nnot a text node.\n\n@docs InlineElement, inlineElement, element, marks, withElement, withMarks\n\n","unions":[{"name":"InlineElement","comment":" `InlineElement` is an element with marks. It represents the contents of an inline node that is\nnot a text node.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"element","comment":" `Element` from an inline element\n","type":"RichText.Model.InlineElement.InlineElement -> RichText.Model.Element.Element"},{"name":"inlineElement","comment":" Creates an inline element from an element and a list of marks\n","type":"RichText.Model.Element.Element -> List.List RichText.Model.Mark.Mark -> RichText.Model.InlineElement.InlineElement"},{"name":"marks","comment":" Marks from an inline element\n","type":"RichText.Model.InlineElement.InlineElement -> List.List RichText.Model.Mark.Mark"},{"name":"withElement","comment":" Creates an inline element with the new `Element`\n","type":"RichText.Model.Element.Element -> RichText.Model.InlineElement.InlineElement -> RichText.Model.InlineElement.InlineElement"},{"name":"withMarks","comment":" Creates an inline element with the new marks\n","type":"List.List RichText.Model.Mark.Mark -> RichText.Model.InlineElement.InlineElement -> RichText.Model.InlineElement.InlineElement"}],"binops":[]},{"name":"RichText.Model.Mark","comment":" A mark is a piece of information that can be attached to an inline node (like color, font, and link information).\n\n\n# Mark\n\n@docs MarkDefinition, Mark, mark, name, attributes, withAttributes\n\n\n# Mark order\n\n@docs MarkOrder, markOrderFromSpec\n\n\n# List helpers\n\n@docs sort, ToggleAction, toggle, hasMarkWithName\n\n","unions":[{"name":"MarkOrder","comment":" A mark order is a way of sorting marks. In order to have a single way of representing a document,\nit's necessary to make sure marks are sorted in a consistent way. Mark orders should be derived\nfrom the spec.\n\n    markOrderFromSpec spec\n    --> returns a mark order that can be used to sort a list of marks\n\n","args":[],"cases":[]},{"name":"ToggleAction","comment":" Actions used to toggle a mark from a list of marks.\n\n  - `Add` adds or replaces a mark if it exists.\n\n  - `Remove` removes all marks with the same name if it exists.\n\n  - `Flip` will remove a mark if a mark with the same name exists, otherwise it will add it.\n\n","args":[],"cases":[["Add",[]],["Remove",[]],["Flip",[]]]}],"aliases":[{"name":"Mark","comment":" A mark is a piece of information defined by a `MarkDefinition` that can be attached to an inline node,\nlike color font, or link information.\n","args":[],"type":"RichText.Internal.Definitions.Mark"},{"name":"MarkDefinition","comment":" A mark definition defines how a mark is encoded an decoded.\n","args":[],"type":"RichText.Internal.Definitions.MarkDefinition"}],"values":[{"name":"attributes","comment":" A list of attributes associated with the mark\n","type":"RichText.Model.Mark.Mark -> List.List RichText.Model.Attribute.Attribute"},{"name":"hasMarkWithName","comment":" Predicate that returns true if the list of marks contains a mark with the given name\n","type":"String.String -> List.List RichText.Model.Mark.Mark -> Basics.Bool"},{"name":"mark","comment":" Creates a mark. The arguments are as follows:\n\n  - `definition` is the `MarkDefinition` that defines this node. Note that even though marks require a mark definition,\n    it's still safe to use `(==)` because the function arguments are not stored on the Mark\n\n  - `attributes` are a list of attributes, for example `[StringAttribute 'href' 'www.google.com']`\n\n```\n    mark link [StringAttribute 'href' 'www.google.com']\n    --> creates a link mark\n```\n\n","type":"RichText.Model.Mark.MarkDefinition -> List.List RichText.Model.Attribute.Attribute -> RichText.Model.Mark.Mark"},{"name":"markOrderFromSpec","comment":" Derives the mark order from the order of the spec's mark definitions, e.g. `(markDefinitions spec)`.\n\n    spec : Spec\n    spec =\n        emptySpec\n            |> withMarkDefinitions\n                [ link\n                , bold\n                , italic\n                , code\n                ]\n\n    markOrderFromSpec spec\n    --> returns a mark order that will sort marks in the following order:  link, bold, italic, and code.\n\n","type":"RichText.Config.Spec.Spec -> RichText.Model.Mark.MarkOrder"},{"name":"name","comment":" Name of the mark\n","type":"RichText.Model.Mark.Mark -> String.String"},{"name":"sort","comment":" Sorts a list of marks from the given `MarkOrder`\n\n    spec : Spec\n    spec =\n        emptySpec\n            |> withMarkDefinitions\n                [ bold\n                , italic\n                ]\n\n    sort (markOrderFromSpec spec) [mark italic [], mark bold []]\n    --> [mark bold [], mark italic []]\n\n","type":"RichText.Model.Mark.MarkOrder -> List.List RichText.Model.Mark.Mark -> List.List RichText.Model.Mark.Mark"},{"name":"toggle","comment":" Returns a list that executes the toggle action and maintains the given mark order.\n\n    -- Assuming the mark order is bold < italic < code:\n    toggle Add (markOrderFromSpec spec) (mark code []) [mark bold [], mark italic []]\n    --> [mark bold [], mark italic [], mark code []]\n\n","type":"RichText.Model.Mark.ToggleAction -> RichText.Model.Mark.MarkOrder -> RichText.Model.Mark.Mark -> List.List RichText.Model.Mark.Mark -> List.List RichText.Model.Mark.Mark"},{"name":"withAttributes","comment":" Creates a mark with new attributes\n","type":"List.List RichText.Model.Attribute.Attribute -> RichText.Model.Mark.Mark -> RichText.Model.Mark.Mark"}],"binops":[]},{"name":"RichText.Model.Node","comment":" This module contains types related to the nodes in an editor.\n\nAn editor consists of two types of nodes, block and inline. `Block` nodes are used to represent\nhierarchical structures like blockquotes, tables and nested lists. Inline nodes are used to\nrepresent flat structures, like text, inline images, and hard breaks.\n\n\n# Block\n\n@docs Block, block, element, childNodes, withElement, withChildNodes\n\n\n# Children\n\n@docs Children, BlockChildren, blockChildren, toBlockArray, InlineChildren, inlineChildren, toInlineArray, toInlineTree, reverseLookup, marksToMarkNodeList\n\n\n# Inline\n\n@docs Inline, InlineTree, inlineElement, marks, plainText, markedText\n\n\n# Path\n\n@docs Path, parent, increment, decrement, toString, commonAncestor\n\n","unions":[{"name":"Block","comment":" A `Block` represents a block element in your document. A block can either\nhave other block nodes as children, have all inline leaf nodes as children (e.g a text block),\nor be a leaf node.\n","args":[],"cases":[]},{"name":"BlockChildren","comment":" `BlockChildren` are child nodes that are all blocks.\n","args":[],"cases":[]},{"name":"Children","comment":" Children represents what children an editor block node can have. A block node may have\nother block nodes as children, inline leaf nodes as children, or it may be a leaf itself.\n","args":[],"cases":[["BlockChildren",["RichText.Model.Node.BlockChildren"]],["InlineChildren",["RichText.Model.Node.InlineChildren"]],["Leaf",[]]]},{"name":"Inline","comment":" An inline leaf node represents an inline element in your document. It can either be an inline\nleaf node, like an image or line break, or a text node.\n","args":[],"cases":[["InlineElement",["RichText.Model.InlineElement.InlineElement"]],["Text",["RichText.Model.Text.Text"]]]},{"name":"InlineChildren","comment":" `InlineChildren` are child nodes that are all inline. Internally, it's represented as both\na flat structure (which can be accessed via `inlineArray`), and a hierarchical structure\n(which can be accessed via `inlineTree`).\n","args":[],"cases":[]},{"name":"InlineTree","comment":" An inline tree is the nested structure of an inline array. Because marks when rendered can span\nmultiple inline nodes, inline content is still technically hierarchical. When rendering or\nparsing, it can be useful to see this information as a tree instead of an array.\n\n  - `MarkNode` node that represents a mark and its inline children\n  - `LeafNode` the index of the inline in the inline array\n\n","args":[],"cases":[["MarkNode",["{ mark : RichText.Model.Mark.Mark, children : Array.Array RichText.Model.Node.InlineTree }"]],["LeafNode",["Basics.Int"]]]}],"aliases":[{"name":"Path","comment":" A node path is a list of indexes that represent the path from a node to a child. It's\nthe main type used to identify where a node is in the editor.\n","args":[],"type":"List.List Basics.Int"}],"values":[{"name":"block","comment":" Creates a block node. The arguments are as follows\n\n  - `element` is the element this block node represents\n  - `childNodes` are the children related to this block node.\n\n```\nblock\n    (Element.element paragraph [])\n    (inlineChildren <| Array.fromList [ plainText \"some text\" ])\n```\n\n","type":"RichText.Model.Element.Element -> RichText.Model.Node.Children -> RichText.Model.Node.Block"},{"name":"blockChildren","comment":" Creates children from a block array\n\n    blockChildren (Array.fromList [ paragraphNode ])\n\n","type":"Array.Array RichText.Model.Node.Block -> RichText.Model.Node.Children"},{"name":"childNodes","comment":" the childNodes from a block node.\n","type":"RichText.Model.Node.Block -> RichText.Model.Node.Children"},{"name":"commonAncestor","comment":" Returns the common ancestor of the two paths.\n\n    commonAncestor [0, 1, 2] [0, 1, 4]\n    --> [0, 1]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path -> RichText.Model.Node.Path"},{"name":"decrement","comment":" Decrements the last index in a node path if one exists.\n\n    decrement [0, 0]\n    --> [0, 0]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path"},{"name":"element","comment":" the element from a block node\n","type":"RichText.Model.Node.Block -> RichText.Model.Element.Element"},{"name":"increment","comment":" Increments the last index in a node path if one exists.\n\n    increment [0, 1]\n    --> [0, 2]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path"},{"name":"inlineChildren","comment":" Creates children derived from an inline array.\n","type":"Array.Array RichText.Model.Node.Inline -> RichText.Model.Node.Children"},{"name":"inlineElement","comment":" Creates an `Inline` from an `Element` and `Mark`\n","type":"RichText.Model.Element.Element -> List.List RichText.Model.Mark.Mark -> RichText.Model.Node.Inline"},{"name":"markedText","comment":" Creates an inline that represents some text with marks\n","type":"String.String -> List.List RichText.Model.Mark.Mark -> RichText.Model.Node.Inline"},{"name":"marks","comment":" Derives the marks from an inline node\n","type":"RichText.Model.Node.Inline -> List.List RichText.Model.Mark.Mark"},{"name":"marksToMarkNodeList","comment":" Transforms a list of list of marks to an array of inline tree nodes\n","type":"List.List (List.List RichText.Model.Mark.Mark) -> Array.Array RichText.Model.Node.InlineTree"},{"name":"parent","comment":" Returns the parent path of the given path\n\n    parent [0, 1, 2]\n    --> [0, 1]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path"},{"name":"plainText","comment":" A Inline that represents plain text\n","type":"String.String -> RichText.Model.Node.Inline"},{"name":"reverseLookup","comment":" a lookup array that maps the index of the inline array to its path in the inline tree\n","type":"RichText.Model.Node.InlineChildren -> Array.Array RichText.Model.Node.Path"},{"name":"toBlockArray","comment":" Returns a block array from block children\n","type":"RichText.Model.Node.BlockChildren -> Array.Array RichText.Model.Node.Block"},{"name":"toInlineArray","comment":" an array of inline nodes (flat structure)\n","type":"RichText.Model.Node.InlineChildren -> Array.Array RichText.Model.Node.Inline"},{"name":"toInlineTree","comment":" a tree of mark nodes with inline leaf indices\n","type":"RichText.Model.Node.InlineChildren -> Array.Array RichText.Model.Node.InlineTree"},{"name":"toString","comment":" String representation of a path.\n\n    toString [0, 0]\n    --> \"0:0\"\n\n","type":"RichText.Model.Node.Path -> String.String"},{"name":"withChildNodes","comment":" a block node with the given children set\n","type":"RichText.Model.Node.Children -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"withElement","comment":" a block node with the given element set\n","type":"RichText.Model.Element.Element -> RichText.Model.Node.Block -> RichText.Model.Node.Block"}],"binops":[]},{"name":"RichText.Model.Selection","comment":" A `Selection` represents the information received and translated from the selection web API. Note that\nthe `anchorNode` and `focusNode` are translations of the node paths relative to the editor.\n\n\n# Selection\n\n@docs Selection, anchorNode, anchorOffset, focusNode, focusOffset\n\n\n# Initialization\n\n@docs caret, singleNodeRange, range\n\n\n# Helpers\n\n@docs isCollapsed, normalize\n\n","unions":[{"name":"Selection","comment":" A `Selection` represents the information received and translated from the selection API. Note that\nthe `anchorNode` and `focusNode` are translations of the node paths relative to the editor.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"anchorNode","comment":" The path to the selection anchor node\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Node.Path"},{"name":"anchorOffset","comment":" The selection anchor offset\n","type":"RichText.Model.Selection.Selection -> Basics.Int"},{"name":"caret","comment":" This is a helper method for constructing a caret selection.\n\n    caret [0, 1] 0\n    --> Creates a selection with { anchorNode=[0,1], anchorOffset=0, focusNode=[0,1], focusOffset=0 }\n\n","type":"RichText.Model.Node.Path -> Basics.Int -> RichText.Model.Selection.Selection"},{"name":"focusNode","comment":" The path to the selection focus node\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Node.Path"},{"name":"focusOffset","comment":" The selection focus offset\n","type":"RichText.Model.Selection.Selection -> Basics.Int"},{"name":"isCollapsed","comment":" This is a helper method for determining if a selection is collapsed.\n\n    isCollapsed <| singleNodeRange [0, 1] 0 1\n    --> False\n\n    isCollapsed <| caret [0, 1] 0\n    --> True\n\n","type":"RichText.Model.Selection.Selection -> Basics.Bool"},{"name":"normalize","comment":" Sorts the selection's anchor to be before the focus. This method is helpful because in the selection\nAPI, a selection's anchor node is not always before a selection's focus node, but when reasoning about editor\noperations, we want the anchor to be before the focus.\n\n    normalize <| range [ 1, 1 ] 0 [ 0, 1 ] 1\n    --> { anchorNode=[0,1], anchorOffset=1, focusNode=[1,1], focusOffset=0 }\n\n    normalize <| singleNodeRange [0, 1] 1 0\n    --> { anchorNode=[0,1], anchorOffset=0, focusNode=[0,1], focusOffset=1 }\n\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Selection.Selection"},{"name":"range","comment":" This is a helper method for creating a range selection\n\n    range [0, 1] 0 [1, 1] 1\n    --> Creates a selection with { anchorNode=[0,1], anchorOffset=0, focusNode=[1,1], focusOffset=1 }\n\n","type":"RichText.Model.Node.Path -> Basics.Int -> RichText.Model.Node.Path -> Basics.Int -> RichText.Model.Selection.Selection"},{"name":"singleNodeRange","comment":" This is a helper method for creating a selection over a single node\n\n    singleNodeRange [0, 1] 0 1\n    --> Creates a selection with { anchorNode=[0,1], anchorOffset=0, focusNode=[0,1], focusOffset=1 }\n\n","type":"RichText.Model.Node.Path -> Basics.Int -> Basics.Int -> RichText.Model.Selection.Selection"}],"binops":[]},{"name":"RichText.Model.State","comment":" A `State` consists of a root block and a selection. `State` allows you to keep\ntrack of and manipulate the contents of the editor.\n\n@docs State, state, root, selection, withRoot, withSelection\n\n","unions":[{"name":"State","comment":" A `State` consists of a root block and a selection. `State` allows you to keep\ntrack of and manipulate the contents of the editor.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"root","comment":" the root node from the state\n","type":"RichText.Model.State.State -> RichText.Model.Node.Block"},{"name":"selection","comment":" the selection from the state\n","type":"RichText.Model.State.State -> Maybe.Maybe RichText.Model.Selection.Selection"},{"name":"state","comment":" Creates a `State`. The arguments are as follows:\n\n  - `root` is a block node that represents the root of the editor.\n\n  - `selection` is a `Maybe Selection` that is the selected part of the editor\n\n```\nroot : Block\nroot =\n    block\n        (Element.element doc [])\n        (blockChildren <|\n            Array.fromList\n                [ block\n                    (Element.element paragraph [])\n                    (inlineChildren <| Array.fromList [ plainText \"\" ])\n                ]\n        )\n\nstate root Nothing\n--> an empty editor state with no selection\n```\n\n","type":"RichText.Model.Node.Block -> Maybe.Maybe RichText.Model.Selection.Selection -> RichText.Model.State.State"},{"name":"withRoot","comment":" a state with the given root\n","type":"RichText.Model.Node.Block -> RichText.Model.State.State -> RichText.Model.State.State"},{"name":"withSelection","comment":" a state with the given selection\n","type":"Maybe.Maybe RichText.Model.Selection.Selection -> RichText.Model.State.State -> RichText.Model.State.State"}],"binops":[]},{"name":"RichText.Model.Text","comment":" `Text` represents an editor text node and associated mark and annotation metadata.\n\n@docs Text, empty, text, marks, annotations, withText, withMarks, withAnnotations\n\n","unions":[{"name":"Text","comment":" `Text` represents an editor text node and associated mark and annotation metadata.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"annotations","comment":" annotations from `Text`\n","type":"RichText.Model.Text.Text -> Set.Set String.String"},{"name":"empty","comment":" empty `Text`\n","type":"RichText.Model.Text.Text"},{"name":"marks","comment":" marks from `Text`\n","type":"RichText.Model.Text.Text -> List.List RichText.Model.Mark.Mark"},{"name":"text","comment":" text from `Text`\n","type":"RichText.Model.Text.Text -> String.String"},{"name":"withAnnotations","comment":" `Text` with the given annotations\n","type":"Set.Set String.String -> RichText.Model.Text.Text -> RichText.Model.Text.Text"},{"name":"withMarks","comment":" `Text` with the given marks\n","type":"List.List RichText.Model.Mark.Mark -> RichText.Model.Text.Text -> RichText.Model.Text.Text"},{"name":"withText","comment":" `Text` with the given text\n","type":"String.String -> RichText.Model.Text.Text -> RichText.Model.Text.Text"}],"binops":[]},{"name":"RichText.Node","comment":" This module contains convenience functions for working with `Block` and `Inline` nodes.\n\n\n# Insert / Replace\n\n@docs insertAfter, insertBefore, replace, replaceWithFragment\n\n\n# Remove\n\n@docs removeInRange, removeNodeAndEmptyParents\n\n\n# Predicates\n\n@docs allRange, anyRange, isEmptyTextBlock, selectionIsBeginningOfTextBlock, selectionIsEndOfTextBlock\n\n\n# Transform\n\n@docs concatMap, indexedMap, joinBlocks, map\n\n\n# Searching\n\n@docs Iterator, last, next, nodeAt, previous, findAncestor, findBackwardFrom, findBackwardFromExclusive, findClosestBlockPath, findForwardFrom, findForwardFromExclusive, findTextBlockNodeAncestor\n\n\n# Folds\n\n@docs foldl, foldlRange, foldr, foldrRange, indexedFoldl, indexedFoldr\n\n\n# Split\n\n@docs splitBlockAtPathAndOffset, splitTextLeaf\n\n\n# Marks\n\n@docs toggleMark\n\n\n# Types\n\nThese are convenience types to wrap around inline and block node and arrays\n\n@docs Fragment, Node\n\n","unions":[{"name":"Fragment","comment":" A `Fragment` represents an array of `Block` or `Inline` nodes. It's a convenience type used\nfor things like insertion or deserialization.\n","args":[],"cases":[["BlockFragment",["Array.Array RichText.Model.Node.Block"]],["InlineFragment",["Array.Array RichText.Model.Node.Inline"]]]},{"name":"Node","comment":" Node represents either a `Block` or `Inline`. It's a convenience type that wraps an argument\nor return value of a function that can use either block or inline, like `nodeAt` or `replace`.\n","args":[],"cases":[["Block",["RichText.Model.Node.Block"]],["Inline",["RichText.Model.Node.Inline"]]]}],"aliases":[{"name":"Iterator","comment":" Type alias for a function that takes a path and a root block and returns a path and node. Useful\nfor generalizing functions like previous and next that can iterate through a Block.\n","args":[],"type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"}],"values":[{"name":"allRange","comment":" Determine if all elements in range satisfy some test.\n\n    -- Query to determine if all the elements in range are selectable\n    allRange isSelectable [ 0, 0 ] [ 0, 2 ] root\n\n","type":"(RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"anyRange","comment":" Determine if any elements in range satisfy some test.\n\n    -- Query to determine if any elements in range are selectable\n    allRange isSelectable [ 0, 0 ] [ 0, 2 ] root\n\n","type":"(RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"concatMap","comment":" Map a given function onto a block's children recursively and flatten the resulting list.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    doubleRoot : Block\n    doubleRoot =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList [ doublePNode, doublePNode ]\n            )\n\n    doublePNode : Block\n    doublePNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode1, textNode2, textNode2 ]\n            )\n\n    concatMap (\\node -> [ node, node ]) rootNode == doubleRoot\n    --> True\n\n","type":"(RichText.Node.Node -> List.List RichText.Node.Node) -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"findAncestor","comment":" Find ancestor from path finds the closest ancestor from the given NodePath that matches the\npredicate.\n\n    -- Finds the closest list item ancestor if it exists\n    findAncestor (\\n -> Element.name (Node.element n) == \"list_item\")\n\n","type":"(RichText.Model.Node.Block -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Model.Node.Block )"},{"name":"findBackwardFrom","comment":" Starting from the given path, scans the node backward until the predicate\nhas been met or it reaches the last node.\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"findBackwardFromExclusive","comment":" Starting from but excluding the given path, scans the node backward until the predicate\nhas been met or it reaches the last node.\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"findClosestBlockPath","comment":" If the node specified by the path is an inline node, returns the parent. If the node at the\npath is a block, then returns the same path. Otherwise if the path is invalid,\nreturns the root path.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    findClosestBlockPath [0, 0] rootNode\n    --> [0]\n    findClosestBlockPath [0] rootNode\n    --> [0]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> RichText.Model.Node.Path"},{"name":"findForwardFrom","comment":" Starting from the given path, scans the node forward until the predicate\nhas been met or it reaches the last node.\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"findForwardFromExclusive","comment":" Starting from but excluding the given path, scans the node forward until\nthe predicate has been met or it reaches the last node.\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> Basics.Bool) -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"findTextBlockNodeAncestor","comment":" Returns Just the parent of the given path if the path refers to an inline node, otherwise\ninline content, otherwisereturn Nothing.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    findTextBlockNodeAncestor [ 0, 0 ] rootNode\n    --> Just ( [ 0 ], pNode )\n\n    findTextBlockNodeAncestor [ 0 ] rootNode\n    --> Nothing ==\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Model.Node.Block )"},{"name":"foldl","comment":" Reduce a node from the top left (e.g. from first to last).\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    nodeNameOrTextValue : Node -> List String -> List String\n    nodeNameOrTextValue node list =\n        (case node of\n            Block bn ->\n                Element.name (Node.element bn)\n\n            Inline il ->\n                case il of\n                    Text tl ->\n                        text tl\n\n                    InlineElement p ->\n                        Element.name (InlineElement.element p)\n        )\n            :: list\n\n    foldl nodeNameOrTextValue [] (Block rootNode)\n    -->  [ \"sample2\", \"sample1\", \"paragraph\", \"doc\" ]\n\n","type":"(RichText.Node.Node -> b -> b) -> b -> RichText.Node.Node -> b"},{"name":"foldlRange","comment":" Same as `foldl` but only applied the nodes between the given paths, inclusive.\n\n    foldlRange [] [ 1 ] nodeNameOrTextValue [] (Block rootNode)\n    -->  [ \"sample2\", \"sample1\", \"paragraph\" ]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path -> (RichText.Node.Node -> b -> b) -> b -> RichText.Model.Node.Block -> b"},{"name":"foldr","comment":" Reduce a node from the bottom right (e.g. from last to first).\n\n    nodeNameOrTextValue : Node -> List String -> List String\n    nodeNameOrTextValue node list =\n        (case node of\n            Block bn ->\n                Element.name (Node.element bn)\n\n            Inline il ->\n                case il of\n                    Text tl ->\n                        text tl\n\n                    InlineElement p ->\n                        Element.name (InlineElement.element p)\n        )\n            :: list\n\n    foldr nodeNameOrTextValue [] (Block rootNode)\n    --> [ \"doc\", \"paragraph\", \"sample1\", \"sample2\" ]\n\n","type":"(RichText.Node.Node -> b -> b) -> b -> RichText.Node.Node -> b"},{"name":"foldrRange","comment":" Same as `foldr` but only applied the nodes between the given paths, inclusive.\n\n    foldlRange [ 0 ] [ 0, 1 ] nodeNameOrTextValue [] (Block rootNode)\n    --> [ \"paragraph\", \"sample1\", \"sample2\" ]\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path -> (RichText.Node.Node -> b -> b) -> b -> RichText.Model.Node.Block -> b"},{"name":"indexedFoldl","comment":" Same as `foldl` but the reduce function also has the current node's path.\n\n    pathList : Path -> Node -> List Path -> List Path\n    pathList path _ list =\n        path :: list\n\n    (indexedFoldl pathList [] (Block rootNode)) == [ [ 0, 1 ], [ 0, 0 ], [ 0 ], [] ]\n\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> b -> b) -> b -> RichText.Node.Node -> b"},{"name":"indexedFoldr","comment":" Same as `foldr` but the reduce function also has the current node's path.\n\n    pathList : Path -> Node -> List Path -> List Path\n    pathList path _ list =\n        path :: list\n\n    (indexedFoldr pathList [] (Block rootNode)) == [ [], [ 0 ], [ 0, 0 ], [ 0, 1 ] ]\n\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> b -> b) -> b -> RichText.Node.Node -> b"},{"name":"indexedMap","comment":" Same as map but the function is also applied with the path of each element (starting at []).\n\n    indexedMap\n        (\\path node ->\n            if path == [ 0, 0 ] then\n                text2\n\n            else\n                node\n        )\n        (Block rootNode)\n    --> replaces the node at [0, 0] with the text2 node\n\n","type":"(RichText.Model.Node.Path -> RichText.Node.Node -> RichText.Node.Node) -> RichText.Node.Node -> RichText.Node.Node"},{"name":"insertAfter","comment":" Inserts the fragments after the node at the given path and returns the result. Returns an\nerror if the path is invalid or the fragment cannot be inserted.\n\n    insertAfter [ 0, 0 ] fragment root\n    --> Inserts the fragment after the node at path [0, 0]\n\n","type":"RichText.Model.Node.Path -> RichText.Node.Fragment -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"insertBefore","comment":" Inserts the fragments before the node at the given path and returns the result. Returns an\nerror if the path is invalid or the fragment cannot be inserted.\n\n    insertBefore [ 0, 0 ] fragment root\n    --> Inserts the fragment before the node at path [0, 0]\n\n","type":"RichText.Model.Node.Path -> RichText.Node.Fragment -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"isEmptyTextBlock","comment":" True if this block has inline content with no children or a single empty text node, false otherwise\n\n    pNode : Block\n        pNode =\n            block\n                (Element.element paragraph [])\n                (inlineChildren <|\n                    Array.fromList [ emptyText ]\n                )\n\n    isEmptyTextBlock pNode\n    --> True\n\n","type":"RichText.Node.Node -> Basics.Bool"},{"name":"joinBlocks","comment":" If the two blocks have the same type of children, returns the joined block. Otherwise, if the\nblocks have different children or one or more is a leaf node, then Nothing is return.\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    pNodeReverse : Block\n    pNodeReverse =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode2, textNode1 ]\n            )\n\n    pNodeExpectedJoin : Block\n    pNodeExpectedJoin =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2, textNode2, textNode1 ]\n            )\n\n    pNodeExpectedJoin == joinBlocks pNode pNodeReverse\n\n","type":"RichText.Model.Node.Block -> RichText.Model.Node.Block -> Maybe.Maybe RichText.Model.Node.Block"},{"name":"last","comment":" Returns the last path and node in the block.\n\n    ( lastPath, lastNode ) =\n        last node\n\n","type":"RichText.Model.Node.Block -> ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"map","comment":" Apply a function to this node and all child nodes.\n\n    setAnnotations : String -> Node -> Node\n    setAnnotations mark node =\n        let\n            annotations =\n                Set.fromList [ mark ]\n        in\n        case node of\n            Block bn ->\n                let\n                    params =\n                        Node.element bn\n                in\n                Block (bn |> withElement (params |> Element.withAnnotations annotations))\n\n            Inline il ->\n                case il of\n                    Text tl ->\n                        Inline (Text (tl |> Text.withAnnotations annotations))\n\n                    InlineElement l ->\n                        let\n                            params =\n                                InlineElement.element l\n                        in\n                        Inline (InlineElement (l |> InlineElement.withElement (params |> Element.withAnnotations annotations)))\n\n    setDummyAnnotation : Node -> Node\n    setDummyAnnotation node =\n        setAnnotations dummyAnnotation node\n\n    map setDummyAnnotation (Block rootNode)\n    --> Recursively adds a dummy annotation to rootNode and all its children\n\n","type":"(RichText.Node.Node -> RichText.Node.Node) -> RichText.Node.Node -> RichText.Node.Node"},{"name":"next","comment":" Returns the next path and node, if one exists, relative to the given path.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    next [0, 0] rootNode == Just ([0, 1], Inline textNode2)\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"nodeAt","comment":" Returns the node at the specified path if it exists.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    nodeAt [0] rootNode == Just (Block pNode)\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe RichText.Node.Node"},{"name":"previous","comment":" Returns the previous path and node, if one exists, relative to the given path.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1, textNode2 ]\n            )\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    textNode2 : Inline\n    textNode2 =\n        plainText \"sample2\"\n\n    previous [0, 1] rootNode == Just ([0, 0], Inline textNode1)\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Path, RichText.Node.Node )"},{"name":"removeInRange","comment":" This method removes all the nodes inclusive to both the start and end path. Note that\nan ancestor is not removed if the start path or end path is a child node.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.fromList [ pNode ])\n\n\n    emptyRoot : Block\n    emptyRoot =\n        block\n            (Element.element doc [])\n            (blockChildren <| Array.empty)\n\n    removeInRange [0] [0] root == emptyRoot\n    --> True\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Path -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"removeNodeAndEmptyParents","comment":" Removes the node at the given path, and recursively removes parent blocks that have no remaining\nchild nodes, excluding the root.\n\n    rootNode : Block\n    rootNode =\n        block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList [ removedPHtmlNode ]\n            )\n\n    pNode : Block\n    pNode =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode ]\n            )\n\n    textNode : Inline\n    textNode =\n        plainText \"sample1\"\n\n    removedRoot : Block\n    removedRoot =\n        block\n            (Element.element doc [])\n            (blockChildren Array.empty)\n\n    removeNodeAndEmptyParents [0, 0] root == removedRoot\n    --> True\n\n","type":"RichText.Model.Node.Path -> RichText.Model.Node.Block -> RichText.Model.Node.Block"},{"name":"replace","comment":" Replaces the node at the path with the given editor node.\n\n    -- replaces the node at [0, 0] with the inline text\n    replace [ 0, 0 ] (Inline textNode) rootNode\n\n","type":"RichText.Model.Node.Path -> RichText.Node.Node -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"replaceWithFragment","comment":" Returns a Ok Block that replaces the node at the node path with the given fragment. If it is\nunable to replace it do to an invalid path or the wrong type of node, a Err string describing\nthe error is returned.\n\n    -- replaces the node at [0, 0] with the given inline fragment\n    replaceWithFragment [ 0, 0 ] (InlineFragment <| Array.fromList [ textNode ]) rootNode\n\n","type":"RichText.Model.Node.Path -> RichText.Node.Fragment -> RichText.Model.Node.Block -> Result.Result String.String RichText.Model.Node.Block"},{"name":"selectionIsBeginningOfTextBlock","comment":" True if the selection is collapsed at the beginning of a text block, false otherwise.\n\n    -- selectionIsBeginningOfTextBlock is used for things like lift and join backward\n    if selectionIsBeginningOfTextBlock selection (State.root editorState) then\n        -- Do join backward logic\n    else\n        -- Do something else\n\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"selectionIsEndOfTextBlock","comment":" True if the selection is collapsed at the end of a text block, false otherwise.\n\n    -- selectionIsEndOfTextBlock is used for things like join forward\n    if selectionIsEndOfTextBlock selection (State.root editorState) then\n        -- Do join forward logic\n    else\n        -- Do something else\n\n","type":"RichText.Model.Selection.Selection -> RichText.Model.Node.Block -> Basics.Bool"},{"name":"splitBlockAtPathAndOffset","comment":" Splits a block at the given path and offset and returns Just the split nodes.\nIf the path is invalid or the node cannot be split, Nothing is returned.\n\n    textNode1 : Inline\n    textNode1 =\n        plainText \"sample1\"\n\n    nodeWithTextLeafToSplit : Block\n    nodeWithTextLeafToSplit =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ textNode1 ]\n            )\n\n    nodeBeforeTextLeafSplit : Block\n    nodeBeforeTextLeafSplit =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ plainText \"sam\" ]\n            )\n\n    nodeAfterTextLeafSplit : Block\n    nodeAfterTextLeafSplit =\n        block\n            (Element.element paragraph [])\n            (inlineChildren <|\n                Array.fromList [ plainText \"ple1\" ]\n            )\n\n    Just (nodeBeforeTextLeafSplit, nodeAfterTextLeafSplit) ==\n        splitBlockAtPathAndOffset [ 0 ] 3 nodeWithTextLeafToSplit\n\n","type":"RichText.Model.Node.Path -> Basics.Int -> RichText.Model.Node.Block -> Maybe.Maybe ( RichText.Model.Node.Block, RichText.Model.Node.Block )"},{"name":"splitTextLeaf","comment":" Splits a text leaf into two based on the given offset.\n\n    splitTextLeaf 1 (emptyText <| withText \"test\")\n    --> (Text \"t\", Text \"est\")\n\n","type":"Basics.Int -> RichText.Model.Text.Text -> ( RichText.Model.Text.Text, RichText.Model.Text.Text )"},{"name":"toggleMark","comment":" Runs the toggle action on the node for the given mark.\n\n    toggleMark Add markOrder bold node\n    --> Adds bold to the given node\n\n","type":"RichText.Model.Mark.ToggleAction -> RichText.Model.Mark.MarkOrder -> RichText.Model.Mark.Mark -> RichText.Node.Node -> RichText.Node.Node"}],"binops":[]},{"name":"RichText.State","comment":" This module contains functions to validate and reduce editor state. These methods are used\nevery time a command is applied.\n\n\n# State functions\n\n@docs reduce, validate\n\n\n# Helpers\n\n@docs translateReducedTextBlockSelection\n\n","unions":[],"aliases":[],"values":[{"name":"reduce","comment":" Reduces the state with the following rules:\n\n  - Neighboring text nodes with the same marks are merged into one text node\n  - Empty text nodes (regardless of marks) that are not part of the current collapsed\n    selection are removed if there is another neighboring text node\n\n```\nbefore : State\nbefore =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <| Array.fromList [ plainText \"te\", plainText \"xt\" ])\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 1 ] 2)\n\n\nafter : State\nafter =\n    state\n        (block\n            (Element.element doc [])\n            (blockChildren <|\n                Array.fromList\n                    [ block\n                        (Element.element paragraph [])\n                        (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                    ]\n            )\n        )\n        (Just <| caret [ 0, 0 ] 4)\n\nreduce before == after\n--> True\n```\n\n","type":"RichText.Model.State.State -> RichText.Model.State.State"},{"name":"translateReducedTextBlockSelection","comment":" Just the selection translation function that gets called in `reduce`. Note that this is really only\nuseful if you're creating transforms that merge or remove inline nodes and you can't find a way\nto easily figure out the new selection state.\n","type":"RichText.Model.Node.Block -> RichText.Model.State.State -> RichText.Model.State.State"},{"name":"validate","comment":" Validates the state against the spec and returns the valid state if everything is okay, otherwise\nreturns a comma separated string of error messages.\n\n    example : State\n    example =\n        state\n            (block\n                (Element.element doc [])\n                (blockChildren <|\n                    Array.fromList\n                        [ block\n                            (Element.element paragraph [])\n                            (inlineChildren <| Array.fromList [ plainText \"text\" ])\n                        ]\n                )\n            )\n            (Just <| caret [ 0, 0 ] 2)\n\n    (Ok example) == (validate markdown example)\n    --> True\n\n","type":"RichText.Config.Spec.Spec -> RichText.Model.State.State -> Result.Result String.String RichText.Model.State.State"}],"binops":[]}]